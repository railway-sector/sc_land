import{eT as be,eU as ye}from"./index-CgzAF5Ey.js";import{a as z,i as xe,z as de,P as he,I as Ce,J as le,l as De,Q as we,E as Te,d as ve,O as ue,m as f,f as Se,c as se,n as J,k as Ie,Y as Me,H as Ee}from"./Point2D-8Py_srEd.js";import{t as te}from"./SimpleGeometryCursor-B92kdZ15.js";import{aM as ce,p as fe,aN as Ve,u as Y,H as _e,d as $,e as U,a as ie,E as W,v as ke,r as ne,a5 as Re,ad as re,aO as Q,am as pe}from"./ProjectionTransformation-D72vYhR2.js";import{Envelope2D as j}from"./Envelope2D-DQ3Tn1o-.js";import{x as oe}from"./Transformation2D-Ckyhe4wc.js";import{o as Ae}from"./OperatorSimplifyOGC-BxMfXpcX.js";import{P as Ye}from"./OperatorGeneralize-BF2-89dP.js";function Be(i,e){const t=i.getGeometryType();return t===z.enumPoint?i:xe(t)?Xe(i):t===z.enumMultiPoint?i:(t===z.enumEnvelope||t===z.enumMultipatch&&de("not implemented for multipatch"),i)}function Xe(i){if(ze(i))return i;const e=i.createInstance();for(let t=0,s=i.getPathCount();t<s;t++){const m=i.getPathSize(t);if(m!==0){if(m===1&&(i.getSegmentCountPath(t)===0||i.getSegmentType(i.getPathStart(t))===z.enumLine||!i.isClosedPath(t)))continue;e.addPath(i,t,!0)}}return e}function ze(i){for(let e=0,t=i.getPathCount();e<t;e++){const s=i.getPathSize(e);if(s===0||s===1&&(i.getSegmentCountPath(e)===0||i.getSegmentType(i.getPathStart(e))===z.enumLine||!i.isClosedPath(e)))return!1}return!0}var y;function F(i,e,t,s,m,r){return{m_from:i.clone(),m_to:e.clone(),m_center:t.clone(),m_next:m,m_type:s}}function Z(i,e,t,s,m){return{m_from:i.clone(),m_to:e.clone(),m_next:t,m_type:4,m_center:new f}}(function(i){i[i.enumDummy=256]="enumDummy",i[i.enumLine=1]="enumLine",i[i.enumArc=2]="enumArc",i[i.enumMiter=8]="enumMiter",i[i.enumBevel=16]="enumBevel",i[i.enumJoinMask=26]="enumJoinMask",i[i.enumConnectionMask=27]="enumConnectionMask"})(y||(y={}));class Le extends te{constructor(e,t,s,m,r,n,h,a,l,o){super(),this.m_index=0,this.m_bufferedPolygon=null,this.m_x=0,this.m_y=0,this.m_progressTracker=o,this.m_parent=e,this.m_mp=t,this.m_distance=s,this.m_spatialReference=m,this.m_densifyDist=a,this.m_maxVertexInCompleteCircle=l,this.m_joins=r,this.m_caps=n,this.m_miterLimit=h}next(){const e=new U;for(;;){if(this.m_index===this.m_mp.getPointCount())return null;if(this.m_caps===1)return this.m_index=this.m_mp.getPointCount(),new Y({vd:this.m_mp.getDescription()});if(this.m_mp.getPointByVal(this.m_index,e),this.m_index++,!e.isEmpty())break}let t,s=!1;if(this.m_bufferedPolygon===null&&(this.m_x=e.getX(),this.m_y=e.getY(),this.m_bufferedPolygon=this.m_parent.buffer(e,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle),s=!0),t=this.m_index<this.m_mp.getPointCount()?this.m_bufferedPolygon.clone():this.m_bufferedPolygon,!s){const m=new oe,r=e.getX()-this.m_x,n=e.getY()-this.m_y;m.setShiftCoords(r,n),t.applyTransformation(m)}return pe(t,0),t}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class qe extends te{constructor(e){super(),this.m_currentPathIndex=0,this.m_polyline=e}next(){if(!this.m_polyline)return null;const e=this.m_polyline.getImpl(),t=e.getPathCount();if(this.m_currentPathIndex<t){const s=this.m_currentPathIndex;if(this.m_currentPathIndex++,!e.isClosedPathInXYPlane(s)){let r=e.getXY(e.getPathEnd(s)-1);for(;this.m_currentPathIndex<e.getPathCount();){const n=e.getXY(e.getPathStart(this.m_currentPathIndex));if(e.isClosedPathInXYPlane(this.m_currentPathIndex)||!n.equals(r))break;r=e.getXY(e.getPathEnd(this.m_currentPathIndex)-1),this.m_currentPathIndex++}}if(s===0&&this.m_currentPathIndex===this.m_polyline.getPathCount()){const r=this.m_polyline;return this.m_polyline=null,r}const m=new $({vd:this.m_polyline.getDescription()});m.addPath(this.m_polyline,s,!0);for(let r=s+1;r<this.m_currentPathIndex;r++)m.addSegmentsFromPath(this.m_polyline,r,0,e.getSegmentCountPath(r),!1);return this.m_currentPathIndex===this.m_polyline.getPathCount()&&(this.m_polyline=null),m}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class Fe extends te{constructor(e,t,s){super(),this.m_geometry=null,this.m_index=0,this.m_bufferer=e,this.m_geoms=t,this.m_index=0,this.m_bFilter=s}next(){if(this.m_geometry===null&&(this.m_index=0,this.m_geometry=this.m_geoms.next(),!this.m_geometry))return null;const e=this.m_geometry.getImpl();if(this.m_index<e.getPathCount()){const t=this.m_index;return this.m_index++,this.m_bufferer.bufferPolylinePath(this.m_geometry,t,this.m_bFilter)}return this.m_geometry=null,this.next()}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class Ne extends te{constructor(e){super(),this.m_index=0,this.m_bufferer=e}next(){const e=this.m_bufferer.m_geometry;if(this.m_index<e.getPathCount()){const t=this.m_index,s=e.calculateRingArea2D(this.m_index);for(J(s>0),this.m_index++;this.m_index<e.getPathCount()&&!(e.calculateRingArea2D(this.m_index)>0);)this.m_index++;let m;return m=t===0&&this.m_index===e.getPathCount()?this.m_bufferer.bufferPolygonImpl(e,0,e.getPathCount()):this.m_bufferer.bufferPolygonImpl(e,t,this.m_index),m}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class tt{constructor(e){this.m_geometry=null,this.m_bufferCommands=[],this.m_originalGeomType=z.enumUnknown,this.m_maxVertexInCompleteCircle=-1,this.m_circleTemplateSize=-1,this.m_oldCircleTemplateSize=0,this.m_spatialReference=null,this.m_tolerance=new ce(0,0),this.m_smallTolerance=new ce(0,0),this.m_filterTolerance=0,this.m_densifyDist=-1,this.m_distance=Number.NaN,this.m_absDistance=0,this.m_absDistanceReversed=0,this.m_dA=-1,this.m_miterLimit=4,this.m_joins=0,this.m_caps=0,this.m_bRoundBuffer=!0,this.m_bOutputLoops=!0,this.m_bFilter=!0,this.m_circleTemplate=[],this.m_leftStack=[],this.m_middleStack=[],this.m_helperLine1=new fe,this.m_helperLine2=new fe,this.m_helperArray=[],this.m_progressCounter=0,this.m_densificator=Ve.constructDefault(e),this.m_progressTracker=e}buffer(e,t,s,m,r,n,h,a){if(e||he("Geometry.Bufferer.Impl.Buffer"),h<0&&he("Geometry.Bufferer.Impl.Buffer"),Ce(e.getGeometryType())&&de("Unsupported geometry type."),e.isEmpty())return new Y({vd:e.getDescription()});if(this.m_joins=m,this.m_caps=r,this.m_bRoundBuffer=!1,this.m_miterLimit=n,this.m_originalGeomType=e.getGeometryType(),le(this.m_originalGeomType)?this.m_bRoundBuffer=this.m_joins===0:De(this.m_originalGeomType)?this.m_bRoundBuffer=this.m_caps===0:we(this.m_originalGeomType)&&(this.m_bRoundBuffer=this.m_joins===0&&this.m_caps===0),this.m_bFilter=this.m_bRoundBuffer,this.m_geometry=Be(e),this.m_geometry.isEmpty())return new Y({vd:e.getDescription()});const l=new j;this.m_geometry.queryLooseEnvelope(l),t>0&&l.inflateCoords(t,t),this.m_tolerance=_e(s,l,!0),this.m_smallTolerance=_e(null,l,!0),a<=0&&(a=96),this.m_spatialReference=s,this.m_distance=t,this.m_absDistance=Math.abs(this.m_distance),this.m_absDistanceReversed=this.m_absDistance!==0?1/this.m_absDistance:0,Number.isNaN(h)||h===0?h=1e-5*this.m_absDistance:h>.5*this.m_absDistance&&(h=.5*this.m_absDistance),a<12&&(a=12);const o=Math.abs(t)*(1-Math.cos(Math.PI/a));if(o>h)h=o;else if(t!==0){const c=Math.PI/Math.acos(1-h/Math.abs(t));c<a-1&&(a=Math.trunc(c))<12&&(a=12,h=Math.abs(t)*(1-Math.cos(Math.PI/a)))}this.m_densifyDist=h,this.m_maxVertexInCompleteCircle=a,this.m_filterTolerance=this.m_bRoundBuffer?Math.min(this.m_smallTolerance.total(),.25*this.m_densifyDist):0,this.m_circleTemplateSize=this.calcN(),this.m_circleTemplateSize!==this.m_oldCircleTemplateSize&&(this.m_circleTemplate.length=0,this.m_oldCircleTemplateSize=this.m_circleTemplateSize),this.m_densifyDist>0&&Te(this.m_geometry)&&(this.m_geometry=this.m_densificator.densifyEx(this.m_geometry,0,this.m_densifyDist,0,this.m_joins!==0,ve()));const u=this.bufferImpl();return this.m_geometry=null,u}generateCircleTemplate(){if(this.m_circleTemplate.length)return;const e=this.m_circleTemplateSize,t=Math.trunc((e+3)/4),s=.5*Math.PI/t;this.m_dA=s,this.m_circleTemplate=ue(f,4*t);const m=Math.cos(s),r=Math.sin(s),n=f.construct(0,1);for(let h=0;h<t;h++)this.m_circleTemplate[h+0*t].setCoords(n.y,-n.x),this.m_circleTemplate[h+1*t].setCoords(-n.x,-n.y),this.m_circleTemplate[h+2*t].setCoords(-n.y,n.x),this.m_circleTemplate[h+3*t].setCoords(n.x,n.y),n.rotateReverse(m,r)}bufferImpl(){const e=this.m_geometry.getGeometryType();if(Se(e)){const t=new $({vd:this.m_geometry.getDescription()});return t.addSegment(this.m_geometry,!0),this.m_geometry=t,this.bufferImpl()}if(this.m_distance<=this.m_tolerance.total()){if(!le(e))return new Y({vd:this.m_geometry.getDescription()});if(this.m_distance<0){const t=new j;if(this.m_geometry.queryEnvelope(t),t.width()<=2*this.m_absDistance||t.height()<=2*this.m_absDistance)return new Y({vd:this.m_geometry.getDescription()})}}switch(this.m_geometry.getGeometryType()){case z.enumPoint:return this.bufferPoint();case z.enumMultiPoint:return this.bufferMultiPoint();case z.enumPolyline:return this.bufferPolyline();case z.enumPolygon:return this.bufferPolygon();case z.enumEnvelope:return this.bufferEnvelope();default:se("")}}bufferPolyline(){if(this.isDegenerateGeometry(this.m_geometry)){const l=new U;this.m_geometry.getPointByVal(0,l);const o=new j;return this.m_geometry.queryEnvelope(o),l.setXY(o.getCenter()),this.bufferDegeneratePath(l,!0)}const e=this.m_geometry,t=this.m_geometry.getDescription();this.m_geometry=null;const s=new qe(e);let m,r;m=this.m_joins===0?new Ye().executeMany(s,.25*this.m_densifyDist,!1,this.m_progressTracker):s,r=this.m_bRoundBuffer?new Ae().executeMany(m,null,!0,this.m_progressTracker):m;const n=new Fe(this,r,this.m_bFilter),h=new ie().executeMany(n,this.m_spatialReference,this.m_progressTracker,2),a=new W().executeMany(h,this.m_spatialReference,!1,this.m_progressTracker).next();return a!==null?a:new Y({vd:t})}bufferPolygon(){if(this.m_distance===0)return this.m_geometry;this.generateCircleTemplate();const e=new W().execute(this.m_geometry,null,!1,this.m_progressTracker);if(this.m_distance<0){if(this.m_geometry=e,this.m_geometry.isEmpty())return this.m_geometry;const t=this.m_geometry,s=this.bufferPolygonImpl(t,0,t.getPathCount());return new W().execute(s,this.m_spatialReference,!1,this.m_progressTracker)}{if(this.m_geometry=e,this.isDegenerateGeometry(this.m_geometry)){const r=new U;this.m_geometry.getPointByVal(0,r);const n=new j;return this.m_geometry.queryEnvelope(n),r.setXY(n.getCenter()),this.bufferDegeneratePath(r,!0)}const t=new Ne(this),s=new ie().executeMany(t,this.m_spatialReference,this.m_progressTracker,2),m=new W().executeMany(s,this.m_spatialReference,!1,this.m_progressTracker).next();return m!==null?m:new Y({vd:this.m_geometry.getDescription()})}}bufferPolygonImpl(e,t,s){const m=e,r=m.getImpl();let n=new Y({vd:e.getDescription()});for(let h=t;h<s;h++){if(r.getPathSize(h)<1)continue;const a=r.calculateRingArea2D(h),l=new j;if(r.queryPathEnvelope(h,l),this.m_distance>0)if(a>0)if(this.isDegeneratePath(r,h)){const o=new U;r.getPointByVal(r.getPathStart(h),o),o.setXY(l.getCenter()),n.add(this.bufferDegeneratePath(o,!0),!1)}else{const o=new $({vd:e.getDescription()}),u=o.getImpl();if(ke(this.m_geometry,h)){const c=this.bufferConvexPath(m,h);n.add(c,!1)}else{this.bufferClosedPath(this.m_geometry,h,u,this.m_bRoundBuffer,1);const c=this.bufferCleanup(o);n.add(c,!1)}}else{if(l.width()+this.m_tolerance.total()<=2*this.m_absDistance||l.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const o=new $({vd:e.getDescription()}),u=o.getImpl();if(this.bufferClosedPath(this.m_geometry,h,u,this.m_bRoundBuffer,1),!o.isEmpty()){const c=l,_=Math.max(1,this.m_absDistance),d=c.clone();d.inflateCoords(_,_),u.addEnvelope(d,!1);const x=this.bufferCleanup(o);n.reserve(n.getPointCount()+x.getPointCount()-4),me(x,n,d,!0)}}else if(a>0){if(l.width()+this.m_tolerance.total()<=2*this.m_absDistance||l.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const o=new $({vd:e.getDescription()}),u=o.getImpl();if(this.bufferClosedPath(this.m_geometry,h,u,this.m_bRoundBuffer,-1),!o.isEmpty()){const c=new j;u.queryLooseEnvelope(c);const _=Math.max(1,this.m_absDistance),d=c.clone();d.inflateCoords(_,_),u.addEnvelope(d,!1),me(this.bufferCleanup(o),n,d,!0)}}else{const o=new $({vd:e.getDescription()}),u=o.getImpl();this.bufferClosedPath(this.m_geometry,h,u,this.m_bRoundBuffer,-1);const c=this.bufferCleanup(o);for(let _=0,d=c.getPathCount();_<d;_++)n.addPath(c,_,!0)}}if(this.m_distance>0)return n.getPathCount()>1?this.bufferCleanup(n):ee(n);{const h=new j;if(n.queryLooseEnvelope(h),n.isEmpty())return ee(n);{const a=Math.max(1,this.m_absDistance),l=h.clone();l.inflateCoords(a,a),n.addEnvelope(l,!1);const o=this.bufferCleanup(n);n=new Y;const u=new Y({vd:o.getDescription()});return me(o,u,l,!1),ee(u)}}}bufferPoint(){return this.bufferPointImpl(this.m_geometry)}bufferPointImpl(e){const t=new Y({vd:e.getDescription()});return this.m_caps===0?(this.addCircle(t.getImpl(),e),this.setStrongSimple(t)):this.m_caps===2?(this.addSquare(t.getImpl(),e),this.setStrongSimple(t)):t}bufferDegeneratePath(e,t){const s=new Y({vd:e.getDescription()});return t&&this.m_joins===0||!t&&this.m_caps===0?(this.addCircle(s.getImpl(),e),this.setStrongSimple(s)):t||this.m_caps!==2?s:(this.addSquare(s.getImpl(),e),this.setStrongSimple(s))}bufferMultiPoint(){const e=new Le(this,this.m_geometry,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle,this.m_progressTracker);return new ie().executeMany(e,this.m_spatialReference,this.m_progressTracker,2).next()}bufferEnvelope(){let e=new Y({vd:this.m_geometry.getDescription()});if(this.m_distance<=0){if(this.m_distance===0)e.addEnvelope(this.m_geometry,!1),ge(this.m_geometry,this.m_tolerance.total())&&(e=this.setStrongSimple(e));else{const s=new ne;this.m_geometry.queryEnvelope(s),s.inflateCoords(this.m_distance,this.m_distance),e.addEnvelope(s,!1),ge(s,this.m_tolerance.total())&&(e=this.setStrongSimple(e))}return e}if(this.m_joins===1){const s=new ne({copy:this.m_geometry});return s.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(s,!1),e}const t=this.m_geometry.clone();if(t.width()===0||t.height()===0){if(t.width()===0&&t.height()===0){const r=new U({vd:this.m_geometry.getDescription()});return t.queryCornerByVal(0,r),this.m_geometry=r,this.bufferImpl()}const s=new $({vd:this.m_geometry.getDescription()}),m=new U;return t.queryCornerByVal(0,m),s.startPathPoint(m),t.queryCornerByVal(2,m),s.lineToPoint(m),this.m_geometry=s,this.bufferImpl()}return e.addEnvelope(this.m_geometry,!1),this.m_geometry=e,this.bufferConvexPath(e,0)}bufferConvexPath(e,t){this.generateCircleTemplate();const s=e.hasAttribute(10),m=new Y({vd:e.getDescription()}),r=m.getImpl();m.reserve((this.m_circleTemplate.length/10+4)*e.getPathSize(t));const n=new f,h=new f,a=new f,l=new f(0,0),o=new f,u=new f,c=e.getImpl(),_=e.getPathSize(t),d=e.getPathStart(t);for(let x=0,b=e.getPathSize(t);x<b;x++){const g=c.getXY(d+x),C=c.getXY(d+(x+1)%_),v=c.getXY(d+(x+2)%_);o.setSub(C,g),o.length()===0&&se("");const D=s&&!!(1&c.getAttributeAsInt(10,(x+1)%_,0));o.normalize();const P=o.clone();o.leftPerpendicularThis(),o.scale(this.m_absDistance),n.setAdd(o,g),h.setAdd(o,C),x===0?r.startPath(n):r.lineTo(n),r.lineTo(h),u.setSub(v,C),u.length()===0&&se(""),u.normalize();const E=u.clone();u.leftPerpendicularThis(),u.scale(this.m_absDistance),a.setAdd(u,C);let V=y.enumArc;const B=D?0:this.m_joins;if(B===2)V=y.enumBevel;else if(B===1){const H=-P.crossProduct(E);l.setSub(P,E),l.scale(this.m_absDistance/H),l.length()<this.m_miterLimit*this.m_absDistance?(l.addThis(C),V=y.enumMiter):V=y.enumBevel}else l.assign(C);this.addJoin(V,r,l,h,a,!1,!1)}return ee(m)}bufferPolylinePath(e,t,s){this.generateCircleTemplate();const m=e,r=m.getImpl();if(r.getPathSize(t)<1)return null;let n;if(n=this.m_bRoundBuffer?r.isClosedPathInXYPlane(t):r.isClosedPath(t),this.isDegeneratePath(r,t)&&this.m_distance>0){const l=new U;r.getPointByVal(r.getPathStart(t),l);const o=new j;return r.queryPathEnvelope(t,o),l.setXY(o.getCenter()),this.bufferDegeneratePath(l,n)}const h=new $({vd:e.getDescription()});h.reserve((Math.trunc(this.m_circleTemplate.length/10)+4)*r.getPathSize(t));const a=h.getImpl();return n?this.bufferClosedPath(m,t,a,s,1)!==2&&this.bufferClosedPath(m,t,a,s,-1):this.bufferOpenPath(m,t,a,s),this.bufferCleanup(h)}progress_(){}bufferCleanup(e,t=!1){const s=t?this.m_tolerance:this.m_smallTolerance;return Re(e,s,!0,!t,-1,this.m_progressTracker,0,!1)}calcN(){if(this.m_densifyDist===0)return this.m_maxVertexInCompleteCircle;const t=1-this.m_densifyDist*Math.abs(this.m_absDistanceReversed);let s=4;return s=t<-1?4:2*Math.PI/Math.acos(t)+.5,s<4?s=4:s>this.m_maxVertexInCompleteCircle&&(s=this.m_maxVertexInCompleteCircle),Math.trunc(s)}addJoin(e,t,s,m,r,n,h){if(this.generateCircleTemplate(),n&&(t.startPath(m),n=!1),e===y.enumBevel)return void(h&&t.lineTo(r));if(e===y.enumMiter){const g=s.clone();return t.lineTo(g),void(h&&t.lineTo(r))}const a=new f;a.setSub(m,s),a.scale(this.m_absDistanceReversed);const l=new f;l.setSub(r,s),l.scale(this.m_absDistanceReversed);let o=Math.atan2(a.y,a.x)/this.m_dA;o<0&&(o=this.m_circleTemplate.length+o),o=this.m_circleTemplate.length-o;let u=Math.atan2(l.y,l.x)/this.m_dA;u<0&&(u=this.m_circleTemplate.length+u),u=this.m_circleTemplate.length-u,u<o&&(u+=this.m_circleTemplate.length);let c=Math.trunc(u),_=Math.ceil(o),d=this.m_circleTemplate[_%this.m_circleTemplate.length].clone();d.scaleAddThis(this.m_absDistance,s);const x=10*this.m_tolerance.total();d.sub(m).length()<x&&(_+=1),d=this.m_circleTemplate[c%this.m_circleTemplate.length].clone(),d.scaleAddThis(this.m_absDistance,s),d.sub(r).length()<x&&(c-=1);let b=c-_;b++;for(let g=0,C=_%this.m_circleTemplate.length;g<b;g++,C=(C+1)%this.m_circleTemplate.length)d=this.m_circleTemplate[C].clone(),d.scaleAddThis(this.m_absDistance,s),t.lineTo(d),this.progress_();h&&t.lineTo(r)}bufferClosedPath(e,t,s,m,r){const n=new re,h=n.addPathFromMultiPath(e,t,!0);return this.bufferClosedPathImpl(n,h,s,m,r)}bufferClosedPathImpl(e,t,s,m,r){const n=e.getFirstVertex(e.getFirstPath(t)),h=new U;if(e.queryPoint(n,h),e.filterClosePoints(this.m_filterTolerance,!1,!1,!1,-1),e.getPointCount(t)<2)return r<0?0:(this.m_bRoundBuffer&&this.addCircle(s,h),2);J(e.getFirstPath(t)!==Q),J(e.getFirstVertex(e.getFirstPath(t))!==Q);const a=e.getXY(e.getFirstVertex(e.getFirstPath(t))),l=new oe;if(l.setShift(a.negate()),e.applyTransformation(l),m){const T=Oe(e,t,r,!0,this.m_absDistance,this.m_filterTolerance,this.m_densifyDist);if(J(T===1),e.getPointCount(t)<2)return r<0?0:(this.addCircle(s,h),2)}const o=this.m_joins!==0&&e.getVertexDescription().hasAttribute(10);this.m_bufferCommands.length=0;const u=e.getFirstPath(t);let c=e.getFirstVertex(u),_=r===1?e.getPrevVertex(c):e.getNextVertex(c),d=r===1?e.getNextVertex(c):e.getPrevVertex(c),x=!0;const b=new f,g=new f,C=new f,v=new f,D=new f,P=new f,E=new f,V=new f,B=this.m_absDistance,H=e.getPathSize(u),L=new f(0,0);for(let T=0;T<H;T++){g.assign(e.getXY(d)),x&&(b.assign(e.getXY(c)),C.assign(e.getXY(_)),P.setSub(b,C),P.normalize(),V.leftPerpendicularOther(P),V.scale(B),v.setAdd(V,b));const p=o&&!!(1&e.getAttributeAsDbl(10,c,0));D.setSub(g,b),D.normalize(),E.leftPerpendicularOther(D),E.scale(B);const A=new f;A.setAdd(b,E);const N=P.crossProduct(D),w=P.dotProduct(D);if(N<0||w<0&&N<Math.abs(w)*Number.EPSILON*8){let X=!1;const q=p?0:this.m_joins;if(q===1){const k=-N;L.setSub(P,D),L.scale(this.m_absDistance/k),L.length()<this.m_miterLimit*this.m_absDistance&&(L.addThis(b),X=!0),this.m_bufferCommands.push(F(v,A,L,X?y.enumMiter:y.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(F(v,A,b,q===0?y.enumArc:y.enumBevel,this.m_bufferCommands.length+1))}else v.equals(A)||(this.m_bufferCommands.push(Z(v,b,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(Z(b,A,this.m_bufferCommands.length+1)));const M=new f;M.setAdd(g,E),this.m_bufferCommands.push(F(A,M,b,y.enumLine,this.m_bufferCommands.length+1)),v.setCoordsPoint2D(M),V.setCoordsPoint2D(E),C.setCoordsPoint2D(b),b.setCoordsPoint2D(g),P.setCoordsPoint2D(D),_=c,c=d,x=!1,d=r===1?e.getNextVertex(c):e.getPrevVertex(c)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),l.setShift(a),s.applyTransformationToPath(l,s.getPathCount()-1),1}bufferOpenPath(e,t,s,m){if(this.m_bRoundBuffer){const p=new $({vd:e.getDescription()});return p.addPath(e,t,!1),p.addSegmentsFromPath(e,t,0,e.getSegmentCountPath(t),!1),this.bufferClosedPath(p,0,s,m,1)}let r=0;const n=new $({vd:e.getDescription()}),h=new f(0,0);{const p=new re,A=p.addPathFromMultiPath(e,t,!1),N=p.getFirstVertex(p.getFirstPath(A)),w=new U;if(p.queryPoint(N,w),h.assign(w.getXY()),p.filterClosePoints(0,!1,!1,!1,-1),p.getPointCount(A)<2)return this.m_bRoundBuffer&&this.addCircle(s,w),2;const M=p.getGeometry(p.getFirstGeometry());n.addPath(M,0,!1),r=n.getPointCount()-1,n.addSegmentsFromPath(M,0,0,M.getSegmentCountPath(0)-1,!1)}const a=new re,l=a.addPathFromMultiPath(n,0,!0);J(a.getFirstPath(l)!==Q),J(a.getFirstVertex(a.getFirstPath(l))!==Q);const o=new oe;o.setShift(h.negate()),a.applyTransformation(o),this.m_bufferCommands.length=0;const u=a.getFirstPath(l),c=this.m_joins!==0&&a.getVertexDescription().hasAttribute(10);let _=a.getFirstVertex(u),d=a.getPrevVertex(_),x=a.getNextVertex(_),b=!0;const g=new f,C=new f,v=new f,D=new f,P=new f,E=new f,V=new f,B=new f,H=this.m_absDistance,L=a.getPathSize(u),T=new f(0,0);for(let p=0;p<L;p++){let A=!1;p!==0&&p!==r||(A=!0),C.assign(a.getXY(x)),b&&(g.assign(a.getXY(_)),v.assign(a.getXY(d)),E.setSub(g,v),E.normalize(),B.leftPerpendicularOther(E),B.scale(H),D.setAdd(B,g));const N=c&&!!(1&a.getAttributeAsDbl(10,_,0));P.setSub(C,g),P.normalize(),V.leftPerpendicularOther(P),V.scale(H);const w=new f;w.setAdd(g,V);const M=E.crossProduct(P),X=E.dotProduct(P);if(M<0||X<0&&M<Math.abs(X)*Number.EPSILON*8)if(A)if(this.m_caps===0)this.m_bufferCommands.push(F(D,w,g,y.enumArc,this.m_bufferCommands.length+1));else if(this.m_caps===1)this.m_bufferCommands.push(F(D,w,g,y.enumLine,this.m_bufferCommands.length+1));else{const k=P.mul(this.m_absDistance).negate(),G=k.clone();k.addThis(D),G.addThis(w),this.m_bufferCommands.push(F(D,k,g,y.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(F(k,G,g,y.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(F(G,w,g,y.enumLine,this.m_bufferCommands.length+1))}else{let k=!1;const G=N?0:this.m_joins;if(G===1){const S=-M;T.setSub(E,P),T.scale(this.m_absDistance/S),T.length()<this.m_miterLimit*this.m_absDistance&&(T.addThis(g),k=!0),this.m_bufferCommands.push(F(D,w,T,k?y.enumMiter:y.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(F(D,w,g,G===0?y.enumArc:y.enumBevel,this.m_bufferCommands.length+1))}else D.equals(w)||(this.m_bufferCommands.push(Z(D,g,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(Z(g,w,this.m_bufferCommands.length+1)));const q=new f;q.setAdd(C,V),this.m_bufferCommands.push(F(w,q,g,y.enumLine,this.m_bufferCommands.length+1)),D.setCoordsPoint2D(q),B.setCoordsPoint2D(V),v.setCoordsPoint2D(g),g.setCoordsPoint2D(C),E.setCoordsPoint2D(P),d=_,_=x,b=!1,x=a.getNextVertex(_)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),o.setShift(h),s.applyTransformationToPath(o,s.getPathCount()-1),1}processBufferCommands(e){const t=this.cleanupBufferCommands();let s=!0,m=t+1;for(let r=t;m!==t;r=m){const n=this.m_bufferCommands[r];m=n.m_next!==-1?n.m_next:(r+1)%this.m_bufferCommands.length,n.m_type&&(s&&(e.startPath(n.m_from),s=!1),n.m_type&y.enumJoinMask?this.addJoin(n.m_type,e,n.m_center,n.m_from,n.m_to,!1,!0):e.lineTo(n.m_to))}}cleanupBufferCommands(){this.m_helperArray=ue(f,9);let e=0;for(let s=0,m=this.m_bufferCommands.length;s<m;){const r=this.m_bufferCommands[s];if(r.m_type&y.enumConnectionMask){e=s;break}s=r.m_next}let t=e+1;for(let s=e;t!==e;s=t){const m=this.m_bufferCommands[s];t=m.m_next;let r=1,n=null;for(;t!==s&&(n=this.m_bufferCommands[t],!(n.m_type&y.enumConnectionMask));)t=n.m_next,r++;r!==1&&(m.m_type&n.m_type)===y.enumLine&&(this.m_helperLine1.setStartXY(m.m_from),this.m_helperLine1.setEndXY(m.m_to),this.m_helperLine2.setStartXY(n.m_from),this.m_helperLine2.setEndXY(n.m_to),this.m_helperLine1.intersect(this.m_helperLine2,this.m_helperArray,null,null,this.m_smallTolerance.total())===1&&(m.m_to.assign(this.m_helperArray[0]),n.m_from.assign(this.m_helperArray[0]),m.m_next=t))}return e}isDegeneratePath(e,t){if(e.getPathSize(t)===1)return!0;if(this.m_joins===0&&this.m_caps===0){const s=new j;if(e.queryPathEnvelope(t,s),Math.max(s.width(),s.height())<.5*this.m_densifyDist)return!0}return!1}isDegenerateGeometry(e){if(this.m_joins===0&&this.m_caps===0){const t=new j;if(e.queryEnvelope(t),Math.max(t.width(),t.height())<.5*this.m_densifyDist)return!0}return!1}addCircle(e,t){const s=t.getXY();if(this.m_circleTemplate.length!==0){let l=this.m_circleTemplate[0].clone();l.scaleAddThis(this.m_absDistance,s),e.startPath(l);for(let o=1,u=this.m_circleTemplate.length;o<u;o++)l=this.m_circleTemplate[o].clone(),l.scaleAddThis(this.m_absDistance,s),e.lineTo(l);return}const m=this.m_circleTemplateSize,r=Math.trunc((m+3)/4),n=.5*Math.PI/r;e.reserve(4*r);const h=Math.cos(n),a=Math.sin(n);for(let l=3;l>=0;l--){const o=f.construct(0,this.m_absDistance);switch(l){case 0:for(let u=0;u<r;u++)e.lineToCoords(o.x+s.x,o.y+s.y),o.rotateReverse(h,a);break;case 1:for(let u=0;u<r;u++)e.lineToCoords(-o.y+s.x,o.x+s.y),o.rotateReverse(h,a);break;case 2:for(let u=0;u<r;u++)e.lineToCoords(-o.x+s.x,-o.y+s.y),o.rotateReverse(h,a);break;default:e.startPathCoords(o.y+s.x,-o.x+s.y);for(let u=1;u<r;u++)o.rotateReverse(h,a),e.lineToCoords(o.y+s.x,-o.x+s.y)}this.progress_()}}addSquare(e,t){const s=new ne({vd:t.getDescription()});s.setCoords(t.getX(),t.getY(),t.getX(),t.getY()),s.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(s,!1)}setStrongSimple(e){return e.getImpl().setIsSimple(4,this.m_tolerance.total()),e.getImpl().updateOGCFlagsProtected(),e}}function ee(i){return pe(i,0),i}function ge(i,e){return!!i.isEmpty()||Math.min(i.width(),i.height())>e}function Ge(i,e,t,s,m,r,n,h){const a=i.getXY(t),l=i.getXY(s);if(a.equals(l))return-1;const o=.25*n,u=.25*n,c=new f;c.setSub(l,a);const _=c.length(),d=_*_*.25,x=r*r-d;if(x<=d)return-1;const b=Math.sqrt(x);c.normalize();const g=c.clone();g.rightPerpendicularThis();const C=d/b,v=C<=u,D=f.lerp(l,a,.5),P=g.clone(),E=C-o;P.scaleAddThis(Math.max(0,E),D),g.negate().scaleAddThis(b,D);const V=3.61*Ee(r-u),B=P.sub(a),H=P.sub(l);let L=!1,T=0;const p=Me(64,0);J(h===p.length);{for(let R=i.getPrevVertexEx(s,m);R!==t;){if(i.getUserIndex(R,e)===1)return-1;if(i.getXY(R).equals(l)){const O=i.getPrevVertexEx(R,m);i.removeVertex(R,!1),R=O;continue}break}const S=new f,I=a.clone();p[T++]=1;for(let R=i.getNextVertexEx(t,m);R!==s;){if(i.getUserIndex(R,e)===1)return-1;const O=i.getXY(R);if(O.equals(I)){const Pe=i.getNextVertexEx(R,m);i.removeVertex(R,!1),R=Pe;continue}p[T++]=0;const ae=new f;if(ae.setSub(O,a),ae.dotProduct(g)<0)return 0;(f.sqrDistance(O,a)>V||f.sqrDistance(O,l)>V)&&(L=!0);let K=0;if(O.sub(a).crossProduct(B)>=0&&(K=1),O.sub(l).crossProduct(H)<=0&&(K|=2),K===0)return 0;p[T-1]=K,S.assign(I),I.assign(O),R=i.getNextVertexEx(R,m)}if(T===1)return 0;J(T<p.length),p[T++]=2}let A=!0;for(let S=1,I=0;S<T;S++)if(p[S]!==p[S-1]&&(I++,A=I<3&&(I===1&&p[S]===3||I===2&&p[S]===2),!A))return 0;if(T>2&&A&&(T===3||!L)){let S=0,I=i.getNextVertexEx(t,m);for(v||(i.setXY(I,P),I=i.getNextVertexEx(I,m));I!==s;){const R=i.getNextVertexEx(I,m);i.removeVertex(I,!1),I=R,++S}return S}if(J(T!==3),L&&T>3)return 0;const N=a.clone();let w=t;const M=a.clone();let X=1,q=-1,k=w,G=0;for(T=1;k!==s;){k=i.getNextVertexEx(k,m);const S=p[T++];if(S===0){if(k===s)break;continue}const I=i.getXY(k);if(q!==-1){if(3&(q&X&S)){i.removeVertex(w,!0),G++,w=k,M.setCoordsPoint2D(I),X=S;continue}if(X===3&&q!==0&&S!==0){if(M.setCoordsPoint2D(P),v||M.equals(N)){i.removeVertex(w,!0),G++,w=k,M.setCoordsPoint2D(I),X=S;continue}i.setXY(w,M)}}q=X,N.setCoordsPoint2D(M),w=k,X=S,M.setCoordsPoint2D(I)}return G}function je(i,e,t,s){let m=-1;const r=new f,n=new f,h=new f;for(let a=0,l=i.getPathSize(s),o=i.getFirstVertex(s);a<l;++a){m===-1&&(i.queryXY(o,n),m=i.getPrevVertex(o),m!==-1&&(i.queryXY(m,r),h.setSub(n,r),h.normalize()));const u=i.getNextVertex(o);if(u===-1)break;const c=i.getXY(u),_=c.sub(n);_.normalize(),m!==-1&&_.dotProduct(h)<-.99&&Math.abs(_.crossProduct(h))<1e-7&&i.setUserIndex(o,e,1),m=o,o=u,r.assign(n),n.assign(c),h.assign(_)}}function $e(i,e,t,s,m,r,n){const h={stack:[],error:void 0,hasError:!1};try{const a=i.getFirstPath(e),l=i.createUserIndex();be(h,Ie(()=>{i.removeUserIndex(l)},!1),!1),je(i,l,e,a);for(let o=0;o<100;++o){if(i.getPathSize(a)===0)return 1;let u=i.getFirstVertex(a),c=i.getPathSize(a);if(c<3)return 1;i.isClosedPath(a)||(c-=1);const _=64;let d=0,x=!1;for(let b=0;b<c&&u!==Q;b++){let g=0,C=u;for(let v=1,D=Math.min(_,c-b);v<D;v++)if(C=i.getNextVertexEx(C,t),v>1){const P=Ge(i,l,u,C,t,m,n,_);if(P===-1)break;g+=P,c-=P}if(d+=g,x=g>0,x){const v=i.getPrevVertexEx(u,t);if(v!==-1){u=v,c++;continue}}u=i.getNextVertexEx(u,t)}if(d===0)break}return i.filterClosePoints(r,!1,!1,!1,-1),1}catch(a){h.error=a,h.hasError=!0}finally{ye(h)}}function Oe(i,e,t,s,m,r,n){return $e(i,e,t,s,m,r,n)}function me(i,e,t,s){for(let m=0,r=i.getPathCount();m<r;m++){const n=i.getXY(i.getPathStart(m));n.x!==t.xmin&&n.x!==t.xmax&&e.addPath(i,m,s)}}export{tt as J,Be as i};
