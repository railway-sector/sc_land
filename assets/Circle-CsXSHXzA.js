import{b0 as d,eP as u,eQ as g,eR as f,eS as b,et as w,eT as m,eU as y,eV as P,eW as R,ag as k,Z as n,$ as h,ad as M,a0 as _}from"./index-Bp3GeDhQ.js";var l;let c=l=class extends d{constructor(e){super(e),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}initialize(){const e=this.center,o=this.numberOfPoints;if(this.hasZ=e?.hasZ??!1,this.rings.length!==0||!e)return;const a=u(this.radius,this.radiusUnit,"meters"),s=e.spatialReference;let i,t="geographic";if(s.isWebMercator?t="webMercator":((s.wkid&&g[s.wkid])!=null||(s.wkt2||s.wkt)&&f(s.wkt2||s.wkt))&&(t="projected"),this.geodesic){let r;switch(t){case"webMercator":r=b(e);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":r=e}i=this._createGeodesicCircle(r,a,o),t==="webMercator"&&(i=w(i))}else{let r;t==="webMercator"||t==="projected"?r=a/m(e.spatialReference):t==="geographic"&&(r=y(a,"meters",P(e.spatialReference).radius)),i=this._createPlanarCircle(e,r,o)}this.spatialReference=i.spatialReference,this.addRing(i.rings[0])}clone(){const{center:e,numberOfPoints:o,radius:a,radiusUnit:s,geodesic:i}=this;return new l({center:e?.clone(),numberOfPoints:o,radius:a,radiusUnit:s,geodesic:i})}_createGeodesicCircle(e,o,a){const s=[],i=[e.x,e.y];for(let t=0;t<360;t+=360/a){const r=this.hasZ?[0,0,e.z??0]:[0,0];R(r,i,t,o,k.WGS84),s.push(r)}return s.push(s[0]),new d({rings:[s]})}_createPlanarCircle(e,o,a){const s=[],i=2*Math.PI/a;for(let t=0;t<a;++t){const r=i*t,p=[e.x+Math.cos(-r)*o,e.y+Math.sin(-r)*o];this.hasZ&&p.push(e.z??0),s.push(p)}return s.push(s[0]),new d({spatialReference:e.spatialReference,rings:[s]})}};n([h({type:M})],c.prototype,"center",void 0),n([h()],c.prototype,"geodesic",void 0),n([h()],c.prototype,"numberOfPoints",void 0),n([h()],c.prototype,"radius",void 0),n([h()],c.prototype,"radiusUnit",void 0),c=l=n([_("esri.geometry.Circle")],c);const C=c;export{C as b};
