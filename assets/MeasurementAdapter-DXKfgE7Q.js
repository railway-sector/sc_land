import{n0 as C,ae as D,ag as k,aj as F,b0 as I,k6 as v,cU as g,mW as R,Z as w,$ as y,a0 as B}from"./index-Bp3GeDhQ.js";import{W as V,L as z,R as S,a as G,Z as H}from"./customElement-CF9iLqAL.js";import{a as O}from"./SketchHandlerMixin-BjOJDMve.js";import"./OrientedImageryLayer-BIQcb3Ox.js";import"./projectOperator-BsNRNJmF.js";import"./operatorProject-C2RzYUdo.js";import"./SimpleGeometryCursor-B92kdZ15.js";import"./ElevationLayer-Dcz5IV0p.js";import"./ArcGISCachedService-CFfozvlu.js";import"./TileInfoTilemapCache-PbAqc6Ly.js";import"./LercDecoder-BpwB2-yq.js";import"./ImageryLayer-BV1-jGx9.js";import"./isImageryGraphicOrigin-Ccuhb4eK.js";import"./multidimensionalUtils-Cl9z6z0B.js";import"./RasterJobHandlerMixin-BAkcQovV.js";import"./RasterSymbolizer-DFWHLI43.js";import"./PixelBlock-B0sCqyr8.js";import"./_commonjsHelpers-DCkdB7M8.js";import"./vectorFieldUtils-B-Ou1tTP.js";import"./datasetUtils-DdDUWBI2.js";import"./ClassBreaksDefinition-1Yd1Xt2l.js";import"./dataUtils-Dxdr1KqJ.js";import"./imageBitmapUtils-B6aKav1r.js";import"./rasterFieldUtils-TjZiQcnR.js";import"./RasterPresetRendererMixin-uQnuvupB.js";import"./executeForIds-kwnn2kK9.js";import"./query-S1DDTf9G.js";import"./pbfQueryUtils-cJlmHg10.js";import"./pbf-BOitBNaq.js";import"./executeQueryJSON-DoeJtOGS.js";import"./GraphicsLayer-n_skBp8O.js";import"./Mesh-DPbDg9NN.js";import"./MeshComponent-D-l7Kso6.js";import"./meshProperties-DWLWd_LJ.js";import"./MeshTransform-DL5XJk6-.js";import"./MeshVertexAttributes-D33qACOJ.js";import"./triangulationUtils-vzO-39rM.js";import"./earcut-D9gy186-.js";import"./deduplicate-BiZEMKl8.js";import"./vertexSpaceConversion-C4BlakVr.js";import"./vec4-Bd0CQOsL.js";import"./External-C4OXoiLK.js";import"./MediaLayer-FjRrJt4Y.js";import"./VideoElement-CcGjr6mK.js";import"./perspectiveUtils-D9PRqmF2.js";import"./normalizeUtilsSync-zs8v83lw.js";import"./ControlPoint-CooeIELo.js";import"./mediaLayerUtils-BJ-DU5EY.js";import"./ImageElement-CEju8AbD.js";import"./BoundsStore-CSsHpZYU.js";import"./Circle-CsXSHXzA.js";import"./deepClone-BtQ2V1Dq.js";import"./languageUtils-BHSX9xR7.js";import"./ImmutableArray-BPVd6ESQ.js";import"./shared-Uanpa3Wf.js";import"./number-DFdmL_Vd.js";import"./Draw-BMeOXFWB.js";import"./SnappingVisualizer2D-BEGrj2v1.js";import"./euclideanLengthMeasurementUtils-D9l_P3ES.js";import"./geometry2dUtils-2tpfJ_8-.js";import"./geodeticLengthOperator-i8Sfrrr_.js";import"./geodeticCurveType-CirnHLSB.js";import"./SnappingVisualizer-BJbr5nBn.js";import"./PointSnappingHint-Dom9ZIp_.js";import"./coordinateHelper-DdBv3hO4.js";import"./EditGeometryOperations-B7ZyEu9w.js";import"./rotate-COZ-KTEt.js";import"./curveOperationUtils-Bwfdd-iC.js";import"./SnappingContext-lR2hMWGP.js";import"./SnappingOperation-BgtHwmXf.js";import"./automaticLengthMeasurementUtils-B7UwQrK7.js";import"./DrawingMode-Cvvf0VVz.js";import"./surfaceCoordinateSystems-1qYrNKOW.js";import"./drawUtils-DdX_qXHr.js";import"./areaOperator-BqSrlAtq.js";import"./Point2D-8Py_srEd.js";import"./Envelope2D-DQ3Tn1o-.js";import"./ProjectionTransformation-lQCY9pCU.js";import"./Transformation2D-Ckyhe4wc.js";import"./OperatorDefinitions-DP7_WWTp.js";import"./jsonConverter-DUGRtN2X.js";import"./apiConverter-jueJBHyz.js";import"./geodeticAreaOperator-Cdc4C0BT.js";import"./geodeticDensifyOperator-BX26z40I.js";import"./operatorGeodeticDensify-BlErwCjW.js";import"./lengthOperator-D89j2ysp.js";import"./simplifyOperator-StSk-cWv.js";import"./operatorSimplify-Dc-q6rdc.js";import"./operators-BpSN9qbc.js";import"./affineTransformOperator-BAhgiQN2.js";import"./operatorGeodesicBuffer-DNoADks-.js";import"./simplifyOGCOperator-DLi-rL1Y.js";import"./OperatorSimplifyOGC-CrVEptTo.js";import"./Transformation-NGHOlRk9.js";import"./bufferOperator-CrSwLgY_.js";import"./operatorBuffer-B81xlSEC.js";import"./Bufferer-Dw9Qi4T1-DTUGJT8s.js";import"./OperatorGeneralize-OmY6cXva.js";import"./centroidOperator-BvDSis81.js";import"./Centroid-DZi-eb9F-bsuFT5fW.js";import"./clipOperator-DGNf8h5v.js";import"./containsOperator-BENbU_gk.js";import"./operatorConvexHull-CeOJMbsr.js";import"./OperatorCrosses-CUq9o_GB.js";import"./cutOperator-DRkmjMLj.js";import"./densifyOperator-D_h8osMG.js";import"./operatorDensify-DxXFlUEx.js";import"./differenceOperator-Bz1kAB0n.js";import"./distanceOperator-nvWTbr2e.js";import"./Distance2DCalculator-CXhBP-8I-4Klp7zPt.js";import"./equalsOperator-6iFbOVj-.js";import"./generalizeOperator-Bw1Eunwl.js";import"./operatorGeneralize-qa-XRMo2.js";import"./intersectionOperator-gU2sAccy.js";import"./operatorIntersection-DDYr4WNS.js";import"./intersectsOperator-CQQ_9bJG.js";import"./OperatorIntersects-BlbA7ULM.js";import"./labelPointOperator-2RpIm18Z.js";import"./OperatorProximity-bJ_5zYYr.js";import"./OperatorOverlaps-C1hOILBP.js";import"./proximityOperator-DAzy-er4.js";import"./relateOperator-CEnaEYCu.js";import"./symmetricDifferenceOperator-xw7AHEHN.js";import"./OperatorTouches-BhmByA-p.js";import"./unionOperator-By4XjY8Y.js";import"./operatorUnion-CM_7A96B.js";import"./OperatorWithin-BgJGb413.js";import"./offset-c1GPLxYn.js";import"./unitConversion-DlAHUMuW.js";import"./operatorOffset-Dw31QsG1.js";import"./ImageryTileLayer-C1bjhQQ4.js";import"./isImageryTileGraphicOrigin-ZR-gBf9D.js";import"./xmlUtilities-BzeSht8y.js";import"./QueueProcessor-MYygY2pz.js";import"./RawBlockCache-Db4zGG2Q.js";import"./rasterProjectionHelper-FeR2zfeq.js";import"./clipUtils-ClqUC2Bl.js";import"./rasterFunctionHelper-BfUirpG9.js";import"./PolynomialTransform-BmM_h0d6.js";import"./SketchViewModel-BRoViF94.js";import"./isSupportedObject-BoTASd6h.js";import"./layerUtils-D3xv-kL2.js";import"./SketchLabelOptions-CvfS2rfH.js";import"./SketchOptions-DkZT37r7.js";import"./SnappingManager-BICxJWyY.js";import"./automaticAreaMeasurementUtils-DsNHnpIJ.js";import"./geodesicAreaMeasurementUtils-CpeJNyDK.js";let p=[],A=[],f=0,u=class extends O(R){constructor(e){super(e),this.type="measurement",this.measurementArray=[],this.pixelMeasurement=0,this.pixelAreaMeasurement=0,this.polygonVertices=[],this._calculationTask=null,this._distanceCalculation=0,this._areaCalculation=null}initialize(){this.addResolvingPromise(C())}async handleCreate(e){const t=e.toolEventInfo;switch(e.tool){case"polyline":await this.handlePolylineEvents(e,t);break;case"polygon":await this.handlePolygonEvents(e,t)}}handleDelete(e){this.resetDistanceMeasurements(),this.resetAreaMeasurements()}handleDestroy(){this.resetDistanceMeasurements(),this.resetAreaMeasurements()}cursorUpdatePolylineHandler(e){const{mode:t,activeViewer:i}=this.viewModel;if(t==="none"||!i?.imageSize)return;if(t==="default")this.measurementArray.push(e.coordinates);else{const s={x:e.coordinates[0],y:e.coordinates[1],z:e.coordinates[2]},o=V(s,i.imageSize[0],i.imageSize[1]);this.measurementArray.push([o.x,o.y])}const a=A.reduce((s,o)=>s+o,0)+this.pixelMeasurement;this.viewModel.distanceMeasurementResult=a}async cursorUpdatePolygonHandler(e){const{mode:t,activeViewer:i}=this.viewModel;if(t==="none"||!i?.imageSize)return;const a=e.coordinates;if(p=[...this.polygonVertices],t==="default")p.push(a);else{const n={x:a[0],y:a[1],z:a[2]},r=V(n,i?.imageSize[0],i?.imageSize[1]);p.push([r.x,r.y])}if(p.length<3||!this.viewModel.currentBestFeature||!this.viewModel.activeViewer?.imageSize)return;const s=p[0];p=p.filter((n,r)=>r===0||r===p.length-1||JSON.stringify(n)!==JSON.stringify(s));const o=await this._getAreaFromTask(p);o?.area&&o?.perimeter&&(f=o.area)}async handlePolylineEvents(e,t){const i=!this.viewModel.accuracyParametersMissing;if(e.state==="cancel")return this.resetDistanceMeasurements(),this.viewModel.distanceMeasurementResult=0,this.viewModel.distanceAccuracyArray=[],void(this.viewModel.displayNewMeasurementButton=!0);if(e.state==="complete"&&e.graphic){if(this.viewModel.activeViewer?.addGraphic(e.graphic),this.viewModel.triangularMeasurementActive){const s=e.graphic.geometry;await this.viewModel.processMeasurementVectors(s.paths[0]),await this._overlayFirstMeasurement(e.graphic,e.tool)}return this.viewModel.measurementGraphic=e.graphic,void this.resetDistanceMeasurements()}switch(t?.type){case"cursor-update":this.cursorUpdatePolylineHandler(t);break;case"vertex-add":if(this.measurementArray.length&&i){const s=await this._getAccuracyFromTask();s&&this.viewModel.distanceAccuracyArray.push(s)}this.vertexUpdatePolylineHandler()}const a=await this._getDistanceFromTask();this.pixelMeasurement=a??this.pixelMeasurement}async handlePolygonEvents(e,t){const i=!this.viewModel.accuracyParametersMissing;if(e.state==="cancel")return this.resetAreaMeasurements(),this.viewModel.areaMeasurementResult=0,this.viewModel.areaMeasurementAccuracy=0,void(this.viewModel.displayNewMeasurementButton=!0);if(e.state==="complete"&&e.graphic){if(this.viewModel.activeViewer?.addGraphic(e.graphic),i){const a=await this._getAreaAccuracyFromTask(this.polygonVertices);this.viewModel.areaMeasurementAccuracy=a&&a>this.viewModel.areaMeasurementAccuracy?a:this.viewModel.areaMeasurementAccuracy}if(this.viewModel.triangularMeasurementActive){const a=e.graphic.geometry;await this.viewModel.processMeasurementVectors(a.rings[0]),await this._overlayFirstMeasurement(e.graphic,e.tool)}return this.viewModel.measurementGraphic=e.graphic,void this.resetAreaMeasurements()}switch(t?.type){case"vertex-add":await this.vertexAddPolygonHandler(t);break;case"cursor-update":await this.cursorUpdatePolygonHandler(t)}this.viewModel.areaMeasurementResult=f>0?f:this.pixelAreaMeasurement}async vertexAddPolygonHandler(e){const{mode:t,activeViewer:i}=this.viewModel,a=e.added,s=a[a.length-1];if(!Array.isArray(s)||t==="none"||!i?.imageSize)return;if(t==="default")this.polygonVertices.push(s);else{const c={x:s[0],y:s[1],z:s[2]},m=V(c,i?.imageSize[0],i?.imageSize[1]);this.polygonVertices.push([m.x,m.y])}if(this.polygonVertices.length<3||!this.viewModel.currentBestFeature||!this.viewModel.activeViewer?.imageSize)return;const o=this.polygonVertices[0];this.polygonVertices=this.polygonVertices.filter((c,m)=>m===0||m===this.polygonVertices.length-1||JSON.stringify(c)!==JSON.stringify(o));const n=await this._getAreaFromTask(this.polygonVertices);if(!n?.area||!n?.perimeter)return;const{area:r}=n;this.pixelAreaMeasurement=r}vertexUpdatePolylineHandler(){this.measurementArray=this.measurementArray.slice(-1);const e=A.reduce((t,i)=>t+i,0)+this.pixelMeasurement;this.viewModel.distanceMeasurementResult=e,this.pixelMeasurement>0&&A.push(this.pixelMeasurement)}resetDistanceMeasurements(){this.measurementArray=[],this.pixelMeasurement=0,A=[]}resetAreaMeasurements(){this.polygonVertices=[],this.pixelAreaMeasurement=0,f=0}async _overlayFirstMeasurement(e,t){switch(t){case"polyline":await this._overlayFirstDistanceMeasurement(e);break;case"polygon":await this._overlayFirstAreaGeometry(e)}}async _overlayFirstDistanceMeasurement(e){const{mode:t,activeTriangulatedViewer:i}=this.viewModel,a=e.geometry?.clone(),s=e.symbol?.clone(),o=i?.imageSize,n=[...a.paths[0]],r=t==="default";if(t==="none"||t==="video"||!o)return;const c=r?n:z(n,o),m=r?S(c,!0):c,h=r?await this.viewModel.getMeasurementProperties():await this.viewModel.getMeasurementPropertiesPanoramic(),d=r?await this.viewModel.getMeasurementProperties(this.viewModel.currentBestFeatureMeasurementImage,this.viewModel.imageMeasurementViewer):await this.viewModel.getMeasurementPropertiesPanoramic(this.viewModel.currentBestFeatureMeasurementImage,this.viewModel.activeTriangulatedViewer);if(m?.length&&h&&d){const M=r?await this.viewModel.imageToImageTransform(m,h,d):await this.viewModel.imageToImageTransformPanoramic(m,h,d),_=M.map(l=>[l.x-.5,-.5-l.y]),T=M.slice(0,2).map(l=>b(l,o)),P=new D({paths:r?[_]:[T],spatialReference:k.WebMercator}),x=new F({geometry:P,symbol:s});await this.viewModel.editOverlayedGraphics(x)}}async _overlayFirstAreaGeometry(e){const{mode:t,activeTriangulatedViewer:i}=this.viewModel,a=e.geometry?.clone(),s=e.symbol?.clone(),o=i?.imageSize,n=[...a.rings[0]],r=t==="default";if(t==="none"||t==="video"||!o)return;const c=r?n:z(n,o),m=r?S(c,!0):c,h=r?await this.viewModel.getMeasurementProperties():await this.viewModel.getMeasurementPropertiesPanoramic(),d=r?await this.viewModel.getMeasurementProperties(this.viewModel.currentBestFeatureMeasurementImage,this.viewModel.imageMeasurementViewer):await this.viewModel.getMeasurementPropertiesPanoramic(this.viewModel.currentBestFeatureMeasurementImage,this.viewModel.activeTriangulatedViewer);if(m?.length&&h&&d){const M=r?await this.viewModel.imageToImageTransform(m,h,d):await this.viewModel.imageToImageTransformPanoramic(m,h,d),_=M.map(l=>[l.x-.5,-.5-l.y]),T=M.slice(0,r?2:M.length).map(l=>b(l,o)),P=new I({rings:r?[_]:[T],spatialReference:k.WebMercator}),x=new F({geometry:P,symbol:s});await this.viewModel.editOverlayedGraphics(x)}}async _getAreaFromTask(e){const{mode:t}=this.viewModel;return this._calculationTask?.abort(),this._calculationTask=v(async i=>{this._areaCalculation=null;const a=await this.viewModel.calculateAreaMeasurement(e,t,i);g(i),this._areaCalculation=a}),await this._calculationTask.promise,this._areaCalculation}async _getDistanceFromTask(){const{mode:e}=this.viewModel;return this._calculationTask?.abort(),this._calculationTask=v(async t=>{this._distanceCalculation=0;const i=await this.viewModel.calculateDistanceMeasurement(this.measurementArray,e,t);g(t),this._distanceCalculation=i}),await this._calculationTask.promise,this._distanceCalculation}async _getAccuracyFromTask(){const{mode:e}=this.viewModel;return e==="none"?null:(this._calculationTask?.abort(),this._calculationTask=v(async t=>{this._distanceCalculation=0;const i=e==="default"?await this.viewModel.calculateAccuracy(this.measurementArray,"distance",t):await this.viewModel.calculateAccuracyPanoramic(this.measurementArray,"distance",void 0,t);g(t),this._distanceCalculation=i}),await this._calculationTask.promise,this._distanceCalculation)}async _getAreaAccuracyFromTask(e){const{mode:t}=this.viewModel;return t==="none"?null:(this._calculationTask?.abort(),this._calculationTask=v(async i=>{this._distanceCalculation=0;const a=t==="default"?await this.viewModel.calculateAccuracy(e,"area",i):await this.viewModel.calculateAccuracyPanoramic(e,"area",void 0,i);g(i),this._distanceCalculation=a}),await this._calculationTask.promise,this._distanceCalculation)}};w([y()],u.prototype,"type",void 0),w([y()],u.prototype,"measurementArray",void 0),w([y()],u.prototype,"pixelMeasurement",void 0),w([y()],u.prototype,"pixelAreaMeasurement",void 0),w([y()],u.prototype,"polygonVertices",void 0),u=w([B("esri.widgets.OrientedImageryViewer.adapters.sketch.MeasurementAdapter")],u);const xi=u,b=(e,t)=>{const{heading:i,pitch:a}=G(e,t[0],t[1]);return H(i,a)};export{xi as default};
