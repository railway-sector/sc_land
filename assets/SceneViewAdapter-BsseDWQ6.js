import{aR as V,nF as F,dq as v,ap as b,ho as L,am as N}from"./index-CgzAF5Ey.js";import{Y as z}from"./Mesh-5O9j34eq.js";import{MeshVertexAttributes as C}from"./MeshVertexAttributes-COLD4CmN.js";import{T as P,C as M,I as W,s as Y,B as J,z as _}from"./customElement-CmlaReIc.js";import{j as E}from"./OrientedImageryLayer-WtDfNKlU.js";import"./MeshComponent-sBtq0OIs.js";import"./meshProperties-DWLWd_LJ.js";import"./MeshTransform-Dit-XLCt.js";import"./triangulationUtils-Bm38jwp7.js";import"./earcut-D9gy186-.js";import"./deduplicate-Cq87yrC4.js";import"./vertexSpaceConversion-DLHSkuCf.js";import"./vec4-DgNhZQgz.js";import"./External-CBuwVgCI.js";import"./a11yUtils-B0k1CDxO.js";import"./projectOperator-GV0McMFO.js";import"./operatorProject-BaCyxOS9.js";import"./SimpleGeometryCursor-B92kdZ15.js";import"./ElevationLayer-BKaFw3VV.js";import"./ArcGISCachedService-DSjNkGng.js";import"./TileInfoTilemapCache-B_wenAXe.js";import"./LercDecoder-BoaSwpxn.js";import"./ImageryLayer-BvGD4I6c.js";import"./isImageryGraphicOrigin-Ccuhb4eK.js";import"./multidimensionalUtils-D7s9wCrf.js";import"./RasterJobHandlerMixin-BTYQtDU0.js";import"./RasterSymbolizer-B91KBOTk.js";import"./PixelBlock-D-6P5OMc.js";import"./pixelRangeUtils-BvOub3JO.js";import"./_commonjsHelpers-DCkdB7M8.js";import"./vectorFieldUtils-BfvwBWsN.js";import"./datasetUtils-DdDUWBI2.js";import"./utils-BxeCvIiv.js";import"./cimSymbolUtils-D8zbHeXT.js";import"./gfxUtils-B1R76T6S.js";import"./ClassBreaksDefinition-8EN4J2v2.js";import"./dataUtils-Bl6288_r.js";import"./imageBitmapUtils-CXji9o1v.js";import"./rasterFieldUtils-owWC2Tqk.js";import"./RasterPresetRendererMixin-B7AjuQMT.js";import"./executeForIds-J9ecr7ox.js";import"./query-CnhzGyzp.js";import"./pbfQueryUtils-S_j2eB_b.js";import"./pbf-BEkcbkvb.js";import"./executeQueryJSON-PzPNmZ_E.js";import"./ExpandViewModel-CyOPQWzt.js";import"./widget-5CKB7XP2.js";import"./GraphicsLayer-CNIUk38A.js";import"./vmEvent-CsrnYMSK.js";import"./MediaLayer-D7zWuWat.js";import"./VideoElement-E5DMr6hw.js";import"./MediaElementView-D6UZnd3c.js";import"./normalizeUtilsSync-BwFfP_Vx.js";import"./ControlPoint-O-tXQDvT.js";import"./mediaLayerUtils-BJ-DU5EY.js";import"./ImageElement-CeMdIsZW.js";import"./BoundsStore-CymG19gy.js";import"./Circle-BiDO0Dld.js";import"./geodesicUtils-Cfv0uT1u.js";import"./deepClone-zSvyy7Jt.js";import"./languageUtils-Ci9pGmfc.js";import"./ImmutableArray-BPVd6ESQ.js";import"./shared-DpUtm4ff.js";import"./number-BNHbRH9q.js";import"./floorFilterUtils-DKzVzLpH.js";import"./MapView-CwKV528N.js";import"./View2D-Z_g1Pe0z.js";import"./clippingUtils-QppW5MR2.js";import"./viewpointUtils-BuigW1az.js";import"./mat2d-DWPHXQcf.js";import"./mat2df64-DJ_RMjZ3.js";import"./mat2df32-Dpt2CT5P.js";import"./hitTestUtils-BYtV70CA.js";import"./rbush-eDLDlHie.js";import"./Tile-B-BE-ibd.js";import"./arcadeUtils-MYBE13Eg.js";import"./Timeline-Cz5T4vl1.js";import"./utils-DN_jc3_L.js";import"./Draw-Bs7q8swp.js";import"./SnappingVisualizer2D-D_sty-M3.js";import"./euclideanLengthMeasurementUtils-CGkbgpIY.js";import"./geometry2dUtils-DamFhDZI.js";import"./geodeticLengthOperator-CCmu1UCP.js";import"./geodeticCurveType-CirnHLSB.js";import"./geodesicMeasurementUtils-CD0H_C-6.js";import"./SnappingVisualizer-CfgCZJq2.js";import"./PointSnappingHint-ByJMd16p.js";import"./coordinateHelper-BBk0eSaI.js";import"./EditGeometryOperations-CUoPE0hp.js";import"./rotate-LRLOFQu1.js";import"./curveOperationUtils-Bf-6qlka.js";import"./SnappingContext-lR2hMWGP.js";import"./SnappingOperation-BCgVE0WW.js";import"./automaticLengthMeasurementUtils-B1DzL2GL.js";import"./DrawingMode-Cvvf0VVz.js";import"./surfaceCoordinateSystems-Czhjgkml.js";import"./drawUtils-DfCzrCmO.js";import"./quantityFormatUtils-hOh9vK9C.js";import"./areaOperator-DccGwebv.js";import"./Point2D-8Py_srEd.js";import"./Envelope2D-DQ3Tn1o-.js";import"./ProjectionTransformation-D72vYhR2.js";import"./Transformation2D-Ckyhe4wc.js";import"./OperatorDefinitions-DP7_WWTp.js";import"./jsonConverter-EjytI4Do.js";import"./apiConverter-CvNJfrRe.js";import"./geodeticAreaOperator-ncO4zfYQ.js";import"./geodeticDensifyOperator-CUM-mSy9.js";import"./operatorGeodeticDensify-D2ygatwM.js";import"./lengthOperator-CxFhBUNM.js";import"./simplifyOperator-CkrCdZRR.js";import"./operatorSimplify-CpftPpUB.js";import"./operators-BaeX3D2r.js";import"./affineTransformOperator-CBep9xo8.js";import"./operatorGeodesicBuffer-C3QQCPQh.js";import"./simplifyOGCOperator-CCJuEH9o.js";import"./OperatorSimplifyOGC-BxMfXpcX.js";import"./Transformation-CfjgNJxz.js";import"./bufferOperator-C3fOKu2I.js";import"./operatorBuffer-Ctfn1Lk3.js";import"./Bufferer-Dw9Qi4T1-DmMU98zV.js";import"./OperatorGeneralize-BF2-89dP.js";import"./centroidOperator-Cn6om9eu.js";import"./Centroid-DZi-eb9F-bsuFT5fW.js";import"./clipOperator-vUzjvvL3.js";import"./containsOperator-DH_4OVBp.js";import"./operatorConvexHull-Dtstnt_d.js";import"./OperatorCrosses-Bo35YEg8.js";import"./cutOperator-Di-dmwJV.js";import"./densifyOperator-BorquEXx.js";import"./operatorDensify-CPsyOzUu.js";import"./differenceOperator-B48dZrcZ.js";import"./distanceOperator-kpocAfUa.js";import"./Distance2DCalculator-CXhBP-8I-RGTjIsY8.js";import"./equalsOperator-BEQPwjuO.js";import"./generalizeOperator-CWNeXtMt.js";import"./operatorGeneralize-BOPizdLP.js";import"./intersectionOperator-Cv1V-QEZ.js";import"./operatorIntersection-ChMpQjPa.js";import"./intersectsOperator-RUQIyyK7.js";import"./OperatorIntersects-Q2s_ZB0E.js";import"./labelPointOperator-CF3FJ9RO.js";import"./OperatorProximity-BBNJFXrK.js";import"./OperatorOverlaps-CqeWwi8u.js";import"./proximityOperator-CJBDpiUf.js";import"./relateOperator-DrBanIAi.js";import"./symmetricDifferenceOperator-heSitsZ5.js";import"./OperatorTouches-CfSdRjLR.js";import"./unionOperator-Dj7O8xPO.js";import"./operatorUnion-ClGNRpq_.js";import"./OperatorWithin-CrxvVT6B.js";import"./offset-CBc0lznI.js";import"./unitConversion-FJJcJ7aj.js";import"./operatorOffset-D6prETIX.js";import"./ImageryTileLayer-DgPV_a3H.js";import"./isImageryTileGraphicOrigin-ZR-gBf9D.js";import"./xmlUtilities-DhOJzv6R.js";import"./QueueProcessor-DIiVPdhP.js";import"./RawBlockCache-CXmw_9Mx.js";import"./rasterProjectionHelper-FtdA54qR.js";import"./clipUtils-CpEsp-yF.js";import"./rasterFunctionHelper-CIXquxIf.js";import"./PolynomialTransform-BTUf5vGs.js";import"./SketchViewModel-DhxBVxKu.js";import"./isSupportedObject-DSxuxd5I.js";import"./layerUtils-C4kbKZbG.js";import"./SketchLabelOptions-CtWdh0ak.js";import"./SketchOptions-DsWZlvNP.js";import"./SnappingManager-C_Xw3YlC.js";import"./automaticAreaMeasurementUtils-BatsSLDN.js";import"./geodesicAreaMeasurementUtils-CadONabs.js";import"./useWidget-DdroRqZj.js";import"./useView-CMtXgKA0.js";class no{constructor(l){this.viewModel=l,this._updateBestFeatureFootprintElevation=!1,this._updatedElevationSampler=null,this.createFootprints=async r=>{const{coverageFrustums:i,currentBestFeature:e,isAdditionalCoverageVisible:m,view:t}=this.viewModel,p=i.filter(V);for(const s of p){let o=s.clone();if(!t.spatialReference.equals(o.spatialReference)){const{components:a,spatialReference:n,origin:c,vertexAttributes:A,vertexSpace:f}=o;if(f.type==="local"){const w=await F(c,t.spatialReference,r);v(r),o.centerAt(w)}else{const w=A.position,x=Float64Array.from(await P([...w],n.clone(),t.spatialReference.clone(),r));v(r),o=new z({vertexAttributes:new C({position:x}),components:a,spatialReference:t.spatialReference.clone()})}}s.imageID===e.attributes.objectId?(this._updateBestFeatureFootprintElevation=!0,this.viewModel.bestFeatureFootprint=new b({attributes:{imageID:s.imageID},geometry:o,symbol:M.clone(),visible:!1})):this.viewModel.additionalFootprints.push(new b({attributes:{imageID:s.imageID},geometry:o,symbol:W.clone(),visible:m}))}},this.updateFootprint=async(r,i,e)=>{const{bestFeatureFootprint:m,currentBestFeature:t,activeViewer:p,footprintExtent:s,view:o,mode:a}=this.viewModel,n=a==="video"?Y:p?.imageSize,c=i??t;if(!(t&&m?.geometry&&n&&s&&c&&o?.spatialReference))return void this.viewModel.updateCurrentCoveragePolygon(null);const{attributes:{cameraHeight:A,location:f,cameraPitch:w,horizontalFieldOfView:x,verticalFieldOfView:B,cameraRoll:D},elevationSample:$}=c;let h=null;if(i&&(this._updatedElevationSampler=t.elevationSample,h=await Q(i,o.spatialReference),this._updatedElevationSampler)){const u=this._updatedElevationSampler?.extent,y=i.attributes.geometry;if(u&&!u.contains(y)){const R=this.viewModel.selectedPoint;if(!R)return;R.x=i.geometry.x,R.y=i.geometry.y;const I=await this.viewModel.processFeatureElevation([i],R);I&&(this._updatedElevationSampler=I)}const[S]=U([h],this._updatedElevationSampler,i);S&&(h=S)}$&&this._updateBestFeatureFootprintElevation&&(this.updateGroundElevation([m]),this._updateBestFeatureFootprintElevation=!1);const O=f.toArray(),k=i&&h?h:m,{vertexAttributes:{position:q},spatialReference:H}=k.geometry,j=await K(q,H,f.spatialReference),G=await this.viewModel.getMapPoint(r,{feature:c,mode:"default",imageSize:n});v(e);let g=G.filter(V);if(!g.length)return;g[0].spatialReference.equals(f.spatialReference)||(g=await Promise.all(g.map(async u=>{const y=await F(u,f.spatialReference,e);return v(e),y})));const T=await J(r.map(({x:u,y})=>[u,y]),g.map(u=>u.toArray()),{cameraHeight:A,cameraLocation:O,cameraPitch:w,frustumVertices:j,horizontalFieldOfView:x,imageHeight:n[1],imageWidth:n[0],inSRS:{wkid:f.spatialReference.wkid},outSRS:{wkid:o.spatialReference.wkid},verticalFieldOfView:B,cameraRoll:D??0,options:e});this.viewModel.updateCurrentCoveragePolygon(new b({attributes:{imageID:c.attributes.objectId},geometry:T,symbol:M.clone(),visible:this.viewModel.currentCoverageVisible}))},this.updateFootprintPanorama=async(r,i)=>{await L(i);const{horizontalFieldOfView:e,pitch:m,verticalFieldOfView:t,yaw:p,feature:s}=r,o=s?.clone()??this.viewModel.currentBestFeature?.clone();if(!o)return;const{attributes:a}=o;a.orientedImageryType=null,a.cameraHeading=(p+a.cameraHeading)%360,a.cameraPitch=m,a.horizontalFieldOfView=e,a.verticalFieldOfView=t,a.cameraRoll=0;const{frustum:n}=_(a);if(!n)return void this.viewModel.updateCurrentCoveragePolygon(null);const c=this.viewModel.view?.spatialReference.equals(n.spatialReference)?n.clone():await F(n.clone(),this.viewModel.view?.spatialReference,i);this.viewModel.updateCurrentCoveragePolygon(new b({attributes:{imageID:a.objectId},geometry:c,symbol:M.clone(),visible:this.viewModel.currentCoverageVisible}))}}updateGroundElevation(l){const{geometry:r,attributes:{elevation:i}}=this.viewModel.currentBestFeature,e=(i??0)*E(r.spatialReference);l.forEach(m=>{const{geometry:t}=m;switch(t?.type){case"mesh":{const{vertexAttributes:{position:p}}=t,s=Math.floor(p.length/3);for(let o=0;o<s;o+=1)p[3*o+2]+=e/E(t.spatialReference);break}case"point":t.z=(t.z??0)+e/E(t.spatialReference)}})}}async function K(d,l,r,i){return Float64Array.from((await Promise.all(d.reduce((e,m,t)=>{const p=Math.floor(t/3);return e[p]=e[p]??[],e[p].push(m),e},new Array).map(async e=>(await F(new N(e,l),r,i)).toArray()))).flat())}const Q=async(d,l,r)=>{const{frustum:i}=_(d.attributes);let e=i.clone();if(!l.equals(e.spatialReference)){const{components:m,spatialReference:t,origin:p,vertexAttributes:s,vertexSpace:o}=e;if(o.type==="local"){const a=await F(p,t,r);v(r),e.centerAt(a)}else{const a=s.position,n=Float64Array.from(await P([...a],t.clone(),t.clone(),r));v(r),e=new z({vertexAttributes:new C({position:n}),components:m,spatialReference:t.clone()})}}return new b({attributes:{imageID:i.imageID},geometry:e,symbol:M.clone(),visible:!1})},U=(d,l,r)=>{const{geometry:i}=r,e=l.queryElevation(i);for(const m of d){const{geometry:t}=m;switch(t?.type){case"mesh":{const{vertexAttributes:{position:p}}=t,s=Math.floor(p.length/3);for(let o=0;o<s;o++)p[3*o+2]+=e?.z??0;break}case"point":t.z=(t.z??0)+(e?.z??0)}}return d};export{no as default};
