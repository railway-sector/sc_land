import{aP as V,mZ as F,d1 as v,ao as b,fZ as Z,ai as L}from"./index-aRi8Xk-b.js";import{Y as z}from"./Mesh-Dxc9QN5X.js";import{MeshVertexAttributes as P}from"./MeshVertexAttributes-myWlh2p7.js";import{T as C,C as M,I as N,s as W,B as Y,z as _}from"./customElement-Duf7jtxI.js";import{j as E}from"./OrientedImageryLayer-DNUkew_7.js";import"./MeshComponent-DO-Vuh-B.js";import"./meshProperties-DWLWd_LJ.js";import"./MeshTransform-DL7voDcB.js";import"./triangulationUtils-Bx6S2VF2.js";import"./earcut-D9gy186-.js";import"./deduplicate-DCdpRX6I.js";import"./vertexSpaceConversion--9VICkO9.js";import"./vec4-CJuiouB0.js";import"./External-CRHviFCd.js";import"./projectOperator-pbpmSpqo.js";import"./operatorProject-Bp6D6u9T.js";import"./SimpleGeometryCursor-B92kdZ15.js";import"./ElevationLayer-BtAhVoF1.js";import"./ArcGISCachedService-D8WBQN18.js";import"./TileInfoTilemapCache-DpPwfrSR.js";import"./LercDecoder-Ba_HK_eF.js";import"./ImageryLayer-C1WpU_1u.js";import"./isImageryGraphicOrigin-Ccuhb4eK.js";import"./multidimensionalUtils-DPCJo6rl.js";import"./RasterJobHandlerMixin-ZMXsKT3M.js";import"./RasterSymbolizer-B_xou3r7.js";import"./PixelBlock-D6s_WAG4.js";import"./_commonjsHelpers-DCkdB7M8.js";import"./vectorFieldUtils-nfa_tg3e.js";import"./datasetUtils-DdDUWBI2.js";import"./ClassBreaksDefinition-DT1Dgqyb.js";import"./dataUtils-BlaM2BDe.js";import"./imageBitmapUtils-DWFhzbXj.js";import"./rasterFieldUtils-ewF5JZJG.js";import"./RasterPresetRendererMixin-BCm-HQgI.js";import"./executeForIds-BOIvqEB-.js";import"./query-zZV_LNG5.js";import"./pbfQueryUtils-Cjywei14.js";import"./pbf-D2pQhulj.js";import"./executeQueryJSON-BsEB0j6G.js";import"./GraphicsLayer-aZe0Dbdm.js";import"./MediaLayer-BSg-18GK.js";import"./VideoElement-B-R-4fHC.js";import"./perspectiveUtils-DkWurYV9.js";import"./normalizeUtilsSync-DladfY4H.js";import"./ControlPoint-roJedap0.js";import"./mediaLayerUtils-BJ-DU5EY.js";import"./ImageElement-oWmrClPK.js";import"./BoundsStore-DeNuAjVw.js";import"./Circle-VvoTd42k.js";import"./deepClone-C3prMmcx.js";import"./languageUtils-BFDfiQjg.js";import"./ImmutableArray-BPVd6ESQ.js";import"./shared-DNQAIdLr.js";import"./number-CRnfhq1R.js";import"./Draw-B5Y6tvI-.js";import"./SnappingVisualizer2D-CuIzKepu.js";import"./euclideanLengthMeasurementUtils-4a6kHLjp.js";import"./geometry2dUtils-CgYtdIFN.js";import"./geodeticLengthOperator-BPMj1oiZ.js";import"./geodeticCurveType-CirnHLSB.js";import"./SnappingVisualizer-DcEQkqUs.js";import"./PointSnappingHint-B1wS2G__.js";import"./coordinateHelper-DuZS2XLt.js";import"./EditGeometryOperations-BtS6ng1n.js";import"./rotate-BMbD9698.js";import"./curveOperationUtils-DNLI8alC.js";import"./SnappingContext-lR2hMWGP.js";import"./SnappingOperation-STPFAn9b.js";import"./automaticLengthMeasurementUtils-CCfVEmrk.js";import"./DrawingMode-Cvvf0VVz.js";import"./surfaceCoordinateSystems-H1MVPt50.js";import"./drawUtils-Br2aF8oP.js";import"./areaOperator-JiNZPKm3.js";import"./Point2D-8Py_srEd.js";import"./Envelope2D-DQ3Tn1o-.js";import"./ProjectionTransformation-CepNZ9PX.js";import"./Transformation2D-Ckyhe4wc.js";import"./OperatorDefinitions-DP7_WWTp.js";import"./jsonConverter-BSFqafDe.js";import"./apiConverter-FnkTMlaa.js";import"./geodeticAreaOperator-DYnNn27m.js";import"./geodeticDensifyOperator-BbdO1oBy.js";import"./operatorGeodeticDensify-CqM-82EQ.js";import"./lengthOperator-B93QPg-F.js";import"./simplifyOperator-BRnc_X18.js";import"./operatorSimplify-BOKlU8rf.js";import"./operators-Ca4ZfP-e.js";import"./affineTransformOperator-CYcPpYBN.js";import"./operatorGeodesicBuffer-9fSni0Zj.js";import"./simplifyOGCOperator-BrAX_zNk.js";import"./OperatorSimplifyOGC-C4cFJI6O.js";import"./Transformation-B5QFC7mB.js";import"./bufferOperator-CSTG6DI2.js";import"./operatorBuffer-CIZ3g07A.js";import"./Bufferer-Dw9Qi4T1-D8yKlGHi.js";import"./OperatorGeneralize-DoFoqaxi.js";import"./centroidOperator-__ITf3sI.js";import"./Centroid-DZi-eb9F-bsuFT5fW.js";import"./clipOperator-B-c7w6tM.js";import"./containsOperator-ClgHXVAE.js";import"./operatorConvexHull-D2b8GS3k.js";import"./OperatorCrosses-h4jZOYNE.js";import"./cutOperator-D3MceKr1.js";import"./densifyOperator-DHWBdh-U.js";import"./operatorDensify-Cd1Qu20O.js";import"./differenceOperator-By7S1Y_y.js";import"./distanceOperator-DXoZ1ofm.js";import"./Distance2DCalculator-CXhBP-8I-Ci-vwecj.js";import"./equalsOperator-VICYJXZz.js";import"./generalizeOperator-DeqIVVGV.js";import"./operatorGeneralize-DgWCTRem.js";import"./intersectionOperator-ClmheFJp.js";import"./operatorIntersection-D5fgKHb0.js";import"./intersectsOperator-C2mY84EI.js";import"./OperatorIntersects-BedDA8cr.js";import"./labelPointOperator-R7L8jZGU.js";import"./OperatorProximity-gMgF6_DS.js";import"./OperatorOverlaps-BeZHQzly.js";import"./proximityOperator-P1L3GlzQ.js";import"./relateOperator-BP9UkBE5.js";import"./symmetricDifferenceOperator-Y7nMmrf_.js";import"./OperatorTouches-8n8ac3eQ.js";import"./unionOperator-DbwqLb2E.js";import"./operatorUnion-D0Yl3krj.js";import"./OperatorWithin-OGsjnXMO.js";import"./offset-C4oRIUmr.js";import"./unitConversion-CuhlvP-p.js";import"./operatorOffset-BnhEHmGh.js";import"./ImageryTileLayer-ahBg2tJx.js";import"./isImageryTileGraphicOrigin-ZR-gBf9D.js";import"./xmlUtilities-BrCIVSt6.js";import"./QueueProcessor-BBZoq4x6.js";import"./RawBlockCache-DcA_xtd5.js";import"./rasterProjectionHelper-B5cSg6T6.js";import"./clipUtils-CIPL8g4V.js";import"./rasterFunctionHelper-Dc05Qk8O.js";import"./PolynomialTransform-D9daHnVQ.js";import"./SketchViewModel-CgPwD4NK.js";import"./isSupportedObject-BODRvkc7.js";import"./layerUtils-kYGDyovj.js";import"./SketchLabelOptions-CdsKprwo.js";import"./SketchOptions-CwjAcyI0.js";import"./SnappingManager-DCRQCwjI.js";import"./automaticAreaMeasurementUtils-BDF5aXgy.js";import"./geodesicAreaMeasurementUtils-thvXrmuo.js";class $i{constructor(l){this.viewModel=l,this._updateBestFeatureFootprintElevation=!1,this._updatedElevationSampler=null,this.createFootprints=async r=>{const{coverageFrustums:i,currentBestFeature:e,isAdditionalCoverageVisible:m,view:t}=this.viewModel,a=i.filter(V);for(const s of a){let o=s.clone();if(!t.spatialReference.equals(o.spatialReference)){const{components:p,spatialReference:n,origin:c,vertexAttributes:A,vertexSpace:f}=o;if(f.type==="local"){const w=await F(c,t.spatialReference,r);v(r),o.centerAt(w)}else{const w=A.position,x=Float64Array.from(await C([...w],n.clone(),t.spatialReference.clone(),r));v(r),o=new z({vertexAttributes:new P({position:x}),components:p,spatialReference:t.spatialReference.clone()})}}s.imageID===e.attributes.objectId?(this._updateBestFeatureFootprintElevation=!0,this.viewModel.bestFeatureFootprint=new b({attributes:{imageID:s.imageID},geometry:o,symbol:M.clone(),visible:!1})):this.viewModel.additionalFootprints.push(new b({attributes:{imageID:s.imageID},geometry:o,symbol:N.clone(),visible:m}))}},this.updateFootprint=async(r,i,e)=>{const{bestFeatureFootprint:m,currentBestFeature:t,activeViewer:a,footprintExtent:s,view:o,mode:p}=this.viewModel,n=p==="video"?W:a?.imageSize,c=i??t;if(!(t&&m?.geometry&&n&&s&&c&&o?.spatialReference))return void this.viewModel.updateCurrentCoveragePolygon(null);const{attributes:{cameraHeight:A,location:f,cameraPitch:w,horizontalFieldOfView:x,verticalFieldOfView:B,cameraRoll:D},elevationSample:$}=c;let h=null;if(i&&(this._updatedElevationSampler=t.elevationSample,h=await K(i,o.spatialReference),this._updatedElevationSampler)){const u=this._updatedElevationSampler?.extent,y=i.attributes.geometry;if(u&&!u.contains(y)){const R=this.viewModel.selectedPoint;if(!R)return;R.x=i.geometry.x,R.y=i.geometry.y;const I=await this.viewModel.processFeatureElevation([i],R);I&&(this._updatedElevationSampler=I)}const[S]=Q([h],this._updatedElevationSampler,i);S&&(h=S)}$&&this._updateBestFeatureFootprintElevation&&(this.updateGroundElevation([m]),this._updateBestFeatureFootprintElevation=!1);const O=f.toArray(),k=i&&h?h:m,{vertexAttributes:{position:H},spatialReference:j}=k.geometry,q=await J(H,j,f.spatialReference),G=await this.viewModel.getMapPoint(r,{feature:c,mode:"default",imageSize:n});v(e);let g=G.filter(V);if(!g.length)return;g[0].spatialReference.equals(f.spatialReference)||(g=await Promise.all(g.map(async u=>{const y=await F(u,f.spatialReference,e);return v(e),y})));const T=await Y(r.map(({x:u,y})=>[u,y]),g.map(u=>u.toArray()),{cameraHeight:A,cameraLocation:O,cameraPitch:w,frustumVertices:q,horizontalFieldOfView:x,imageHeight:n[1],imageWidth:n[0],inSRS:{wkid:f.spatialReference.wkid},outSRS:{wkid:o.spatialReference.wkid},verticalFieldOfView:B,cameraRoll:D??0,options:e});this.viewModel.updateCurrentCoveragePolygon(new b({attributes:{imageID:c.attributes.objectId},geometry:T,symbol:M.clone(),visible:this.viewModel.currentCoverageVisible}))},this.updateFootprintPanorama=async(r,i)=>{await Z(i);const{horizontalFieldOfView:e,pitch:m,verticalFieldOfView:t,yaw:a,feature:s}=r,o=s?.clone()??this.viewModel.currentBestFeature?.clone();if(!o)return;const{attributes:p}=o;p.orientedImageryType=null,p.cameraHeading=(a+p.cameraHeading)%360,p.cameraPitch=m,p.horizontalFieldOfView=e,p.verticalFieldOfView=t,p.cameraRoll=0;const{frustum:n}=_(p);if(!n)return void this.viewModel.updateCurrentCoveragePolygon(null);const c=this.viewModel.view?.spatialReference.equals(n.spatialReference)?n.clone():await F(n.clone(),this.viewModel.view?.spatialReference,i);this.viewModel.updateCurrentCoveragePolygon(new b({attributes:{imageID:p.objectId},geometry:c,symbol:M.clone(),visible:this.viewModel.currentCoverageVisible}))}}updateGroundElevation(l){const{geometry:r,attributes:{elevation:i}}=this.viewModel.currentBestFeature,e=(i??0)*E(r.spatialReference);l.forEach(m=>{const{geometry:t}=m;switch(t?.type){case"mesh":{const{vertexAttributes:{position:a}}=t,s=Math.floor(a.length/3);for(let o=0;o<s;o+=1)a[3*o+2]+=e/E(t.spatialReference);break}case"point":t.z=(t.z??0)+e/E(t.spatialReference)}})}}async function J(d,l,r,i){return Float64Array.from((await Promise.all(d.reduce((e,m,t)=>{const a=Math.floor(t/3);return e[a]=e[a]??[],e[a].push(m),e},new Array).map(async e=>(await F(new L(e,l),r,i)).toArray()))).flat())}const K=async(d,l,r)=>{const{frustum:i}=_(d.attributes);let e=i.clone();if(!l.equals(e.spatialReference)){const{components:m,spatialReference:t,origin:a,vertexAttributes:s,vertexSpace:o}=e;if(o.type==="local"){const p=await F(a,t,r);v(r),e.centerAt(p)}else{const p=s.position,n=Float64Array.from(await C([...p],t.clone(),t.clone(),r));v(r),e=new z({vertexAttributes:new P({position:n}),components:m,spatialReference:t.clone()})}}return new b({attributes:{imageID:i.imageID},geometry:e,symbol:M.clone(),visible:!1})},Q=(d,l,r)=>{const{geometry:i}=r,e=l.queryElevation(i);for(const m of d){const{geometry:t}=m;switch(t?.type){case"mesh":{const{vertexAttributes:{position:a}}=t,s=Math.floor(a.length/3);for(let o=0;o<s;o++)a[3*o+2]+=e?.z??0;break}case"point":t.z=(t.z??0)+(e?.z??0)}}return d};export{$i as default};
