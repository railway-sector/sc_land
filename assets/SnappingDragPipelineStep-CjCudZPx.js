import{aT as b,k as L,aU as M,aV as A,aW as D,aX as F,aM as N,aY as j,aZ as V}from"./index-CVzGOCNQ.js";import{a as W}from"./dehydratedFeatureComparison-Jxs38VhS.js";import{D as X}from"./dragEventPipeline-DBXPcfSM.js";import{e as Y}from"./SnappingContext-lR2hMWGP.js";function tn({predicate:n=()=>!0,snappingManager:e,snappingContext:a,updatingHandles:o,useZ:t=!0}){const l=new X;if(e==null)return{snappingStep:[w,l],cancelSnapping:w};let c,u=null,i=null,p=null;const f=()=>{u=M(u),e.doneSnapping(),i?.frameTask.remove(),i=null,c=A(c),p=null},m=q(e,t,l);let d=null,s=null,Z=null;return{snappingStep:[r=>{if(!n(r))return r;const{action:P}=r;if(P==="start"){const{info:x}=r,S=B(e.view);if(i=J(a,r,S),i.context.selfSnappingZ=null,!t&&x!=null){const g=Q(a.coordinateHelper,x.handle.part);g!=null&&(i.context.selfSnappingZ={value:g,elevationInfo:a.elevationInfo??b})}}if(i!=null){const{context:x,originalScenePos:S,originalPos:g}=i,{mapEnd:T,mapStart:$,scenePoints:C}=r,v=I(g,y(T,$)),k=y($,g),E={...r,action:"update"},G=i.context,h=K(S,C),z=e.update({point:v,scenePoint:h,context:x});if(Z=z,U(T,z,k,t),d=v,s=h,P!=="end"){const{frameTask:H}=i;u==null&&(u=new AbortController),p=O=>{o.addPromise(j(m({frameTask:H,event:E,context:G,point:v,scenePoint:h,delta:k,getLastState:()=>({point:d,scenePoint:s,updatePoint:O.forceUpdate?null:Z})},u.signal)))},p({forceUpdate:!1}),c==null&&(c=L(()=>e.options.effectiveEnabled,()=>p?.({forceUpdate:!0})))}}return P==="end"&&f(),r},l],cancelSnapping:r=>(f(),r)}}function q(n,e,a){return V(async({frameTask:o,point:t,scenePoint:l,context:c,event:u,delta:i,getLastState:p},f)=>{const m=await o.schedule(()=>n.snap({point:t,scenePoint:l,context:c,signal:f}),f);if(m.valid){let d=await o.schedule(()=>m.apply(),f);const s=p();s.point!=null&&t!==s.point&&(d=n.update({point:s.point,scenePoint:s.scenePoint,context:c})),s.updatePoint!=null&&W(d,s.updatePoint)||(U(u.mapEnd,d,i,e),a.execute(u))}})}function B(n){return n.type==="3d"?n.resourceController.scheduler.registerTask(F.SNAPPING):D}function J(n,e,a){return{context:new Y({editGeometryOperations:n.editGeometryOperations,elevationInfo:n.elevationInfo,pointer:n.pointer,vertexHandle:e.info!=null?e.info.handle:null,excludeFeature:n.excludeFeature,feature:n.feature,visualizer:n.visualizer}),originalPos:e.snapOrigin!=null?n.coordinateHelper.vectorToDehydratedPoint(e.snapOrigin):e.mapStart,originalScenePos:e.scenePoints!=null?e.scenePoints.sceneStart:null,frameTask:a}}function I(n,[e,a,o]){const t=N(n);return t.x+=e,t.y+=a,t.hasZ&&(t.z+=o),t}function K(n,e){return n==null||e==null?null:I(n,y(e.sceneEnd,e.sceneStart))}function y(n,e){const a=n.hasZ&&e.hasZ?n.z-e.z:0;return[n.x-e.x,n.y-e.y,a]}function U(n,e,[a,o,t],l){n.x=e.x+a,n.y=e.y+o,l&&n.hasZ&&e.hasZ&&(n.z=e.z+t)}function Q(n,e){if(!n.hasZ())return null;const a=e.vertices;let o=null;for(const t of a){const l=n.getZ(t.pos);if(o!=null&&l!=null&&Math.abs(l-o)>1e-6)return null;o==null&&(o=l)}return o}function w(n){return n}export{tn as f};
