const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/SelfSnappingEngine-Dz_QIOg6.js","assets/index-aRi8Xk-b.js","assets/index-ni9qn0ie.css","assets/euclideanLengthMeasurementUtils-4a6kHLjp.js","assets/geometry2dUtils-CgYtdIFN.js","assets/geodeticLengthOperator-BPMj1oiZ.js","assets/geodeticCurveType-CirnHLSB.js","assets/angularMeasurementUtils-aJNkDwXZ.js","assets/GridSnappingEngine-CubUE-X6.js","assets/gridUtils-Bl6T9-nG.js","assets/FeatureSnappingEngine-DE9QwSw9.js"])))=>i.map(i=>d[i]);
import{dZ as G,bj as U,i0 as W,bc as w,aF as F,ar as T,aG as B,aI as J,Cq as Y,am as K,sJ as N,sK as z,aX as Q,hY as X,kv as tt,cR as et,j as q,a8 as it,kb as nt,eB as st,a3 as C,d1 as E,aU as M,eF as at,aY as L,jJ as rt,a5 as f,x as g,y as ot}from"./index-aRi8Xk-b.js";import{Q as ht,a as c,R as dt,n as ct,i as pt,S as j,B as k,r as lt,b as A,G as ut,s as V,u as ft,g as gt,C as y,j as x,E as I,y as _t,L as St,p as H}from"./euclideanLengthMeasurementUtils-4a6kHLjp.js";class S{constructor(t,i,n,s){this.targetPoint=t,this.constraint=i,this.isDraped=n,this.domain=s}}let Z=class extends S{constructor({targetPoint:t,objectId:i,constraint:n,isDraped:s}){super(t,n,s,1),this.objectId=i}};class vt extends Z{constructor(t){super({...t,isDraped:!0,constraint:new ht(t.edgeStart,t.edgeEnd,t.getGroundElevation)})}get hints(){return[new c(1,this.constraint.start,this.constraint.end,this.isDraped,this.domain)]}}let wt=class extends Z{constructor(t){super({...t,constraint:new dt(t.edgeStart,t.edgeEnd)})}get hints(){return[new c(1,this.constraint.start,this.constraint.end,this.isDraped,this.domain)]}},m=class extends S{constructor(t,i,n,s){super(t,new ct(t),s,3),this.first=i,this.second=n}get hints(){return this.first.targetPoint=this.targetPoint,this.second.targetPoint=this.targetPoint,[...this.first.hints,...this.second.hints,new pt(this.targetPoint,this.isDraped,this.domain)]}},yt=class extends S{constructor({lineStart:t,lineEnd:i,targetPoint:n,isDraped:s}){super(n,new j(t,i),s,2),this._referenceLineHint=new c(2,t,i,s,this.domain)}get hints(){return[this._referenceLineHint,new c(0,this._lineEndClosestToTarget(),this.targetPoint,this.isDraped,this.domain)]}_lineEndClosestToTarget(){return this.constraint.closestEndTo(this.targetPoint)}};class Pt extends S{constructor({referenceLine:t,lineStart:i,targetPoint:n,isDraped:s}){const a=G(i),{left:r,right:o}=t;U(a,W(a,a,o),r),super(n,new j(i,k(a)),s,2),this._referenceLines=[{edge:t,fadeLeft:!0,fadeRight:!0}]}get hints(){return[new c(0,this.constraint.start,this.targetPoint,this.isDraped,this.domain),new lt(this.constraint.start,this.targetPoint,this.isDraped,this.domain),...this._referenceLines.map(t=>new c(1,t.edge.left,t.edge.right,this.isDraped,this.domain,t.fadeLeft,t.fadeRight))]}addReferenceLine(t){const i={edge:t,fadeLeft:!0,fadeRight:!0};this._referenceLines.forEach(n=>{w(t.right,n.edge.left)&&(n.fadeLeft=!1,i.fadeRight=!1),w(t.right,n.edge.right)&&(n.fadeRight=!1,i.fadeRight=!1),w(t.left,n.edge.right)&&(n.fadeRight=!1,i.fadeLeft=!1),w(t.left,n.edge.left)&&(n.fadeLeft=!1,i.fadeLeft=!1)}),this._referenceLines.push(i)}}class mt extends S{constructor({targetPoint:t,constraint:i,previousVertex:n,otherVertex:s,otherVertexType:a,isDraped:r,selfSnappingType:o,objectId:d,domain:h}){super(t,i,r,h??2),this.previousVertex=n,this.otherVertex=s,this.otherVertexType=a,this.selfSnappingType=o??0,this.objectId=d??null}get hints(){const t=this.previousVertex,i=this.otherVertexType===1?this.otherVertex:this.targetPoint,n=this.otherVertexType===1?this.targetPoint:this.otherVertex;return[new c(0,i,n,this.isDraped,this.domain),new c(1,t,i,this.isDraped,this.domain),new A(this.previousVertex,i,n,this.isDraped,this.domain)]}}let Tt=class extends S{constructor({targetPoint:t,point1:i,point2:n,isDraped:s}){super(t,new ut(k(F(T(),i,n,.5)),.5*B(V(i),V(n))),s,2),this._p1=i,this._p2=n}get hints(){return[new c(1,this.targetPoint,this._p1,this.isDraped,this.domain),new c(1,this.targetPoint,this._p2,this.isDraped,this.domain),new A(this._p1,this.targetPoint,this._p2,this.isDraped,this.domain)]}};function kt(e,t,i,n){const s=i.projectToRenderScreen(e,xt),a=i.projectToRenderScreen(t,$t);return s==null||a==null?null:(K(n,a,s),N(n,n),n)}function Ct(e,t,i,n,s=T()){const a=J(Et,e);return a[2]=Y(n,a,t,i)||0,n.renderCoordsHelper.toRenderCoords(a,t,s),s}const Et=T(),xt=z(),$t=z();function Rt(e,t,i,n){return n.type==="2d"?(P.x=e[0],P.y=e[1],P.spatialReference=t,n.toScreen(P)):(Ct(e,t,i,n,O),n.state.camera.projectToScreen(O,$),Q($[0],$[1]))}const P=X(0,0,0,null),O=T(),$=tt();let l=class extends et{constructor(e){super(e),this.options=new ft,this._engineCache=new Map,this._loadTask=null,this._engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=0}initialize(){this.addHandles([q(()=>{const{distance:e,touchSensitivityMultiplier:t,effectiveSelfEnabled:i,effectiveFeatureEnabled:n,effectiveGridEnabled:s}=this.options;return{selfEnabled:i,featureEnabled:n,gridEnabled:this.view.type==="2d"&&s,viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,distance:e,touchSensitivityMultiplier:t}},(e,t)=>{t&&(this.doneSnapping(),this.emit("changed")),this._loadTask?.abort(),this._loadTask=nt(i=>this._updateEngines(e,t,i))},it),q(()=>this.options,e=>{for(const t of this._engines)t.options=e},st)])}destroy(){this._loadTask?.abort(),this._destroyEngines()}get updating(){return this._engines.some(e=>e.updating)||!this._loadTask?.finished}_destroyEngines(){this._engineCache.forEach(e=>e.destroy()),this._engineCache.clear(),this._engines=[]}async _updateEngines(e,t,i){if(!e.viewReady)return void this._destroyEngines();t?.viewSpatialReference!==e.viewSpatialReference&&this._destroyEngines();const n=this._engineCache,s=await Promise.allSettled([e.featureEnabled&&!n.has("feature")?this._createFeatureSnappingEngine(i):void 0,e.selfEnabled&&!n.has("self")?this._createSelfSnappingEngine(i):void 0,e.gridEnabled&&!n.has("grid")?this._createGridSnappingEngine(i):void 0]);if(i.aborted)for(const a of s)a.status==="fulfilled"&&a.value?.engine.destroy();else{for(const a of s)a.status==="fulfilled"&&a.value&&n.set(a.value.type,a.value.engine);this._engines=Array.from(n.values())}}async _createSelfSnappingEngine(e){const[{SelfSnappingEngine:t},i]=await Promise.all([C(()=>import("./SelfSnappingEngine-Dz_QIOg6.js"),__vite__mapDeps([0,1,2,3,4,5,6,7])),gt()]);return E(e),{type:"self",engine:new t({view:this.view,options:this.options,geodesicLengthMeasurementUtils:i})}}async _createGridSnappingEngine(e){const{view:t}=this;if(t.type!=="2d")return;const{GridSnappingEngine:i}=await C(()=>import("./GridSnappingEngine-CubUE-X6.js"),__vite__mapDeps([8,1,2,9,3,4,5,6]));return E(e),{type:"grid",engine:new i({view:t,options:this.options})}}async _createFeatureSnappingEngine(e){const{FeatureSnappingEngine:t}=await C(()=>import("./FeatureSnappingEngine-DE9QwSw9.js"),__vite__mapDeps([10,1,2,3,4,5,6]));E(e);const{view:i,options:n}=this,{spatialReference:s}=i;return{type:"feature",engine:new t({view:i,options:n,spatialReference:s})}}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}snap(e){return Lt(e)?this._snapMultiPoint(e):this._snapSinglePoint(e)}update(e){const{point:t,context:i}=e;this._removeVisualization();const n=this._currentMainCandidate;if(n==null)return t;const s=this._selectUpdateInput(e);if(s==null)return t;const{spatialReference:a}=i,r=M(s,a);if(r==null)return t;const{view:o}=this,{elevationInfo:d,visualizer:h}=i,p=[],u=y(r,o,d),_=n.constraint.closestTo(u);if(!this._arePointsWithinScreenThreshold(u,_,i)||!D(n,i.drawConstraints))return this._resetSnappingState(),t;n.targetPoint=x(_),p.push(...n.hints);for(const v of this._currentOtherActiveCandidates)D(v,i.drawConstraints)&&(v.targetPoint=x(_),p.push(...v.hints));return h!=null&&this.addHandles(h.draw(p,{spatialReference:a,elevationInfo:qt(i),view:o,selfSnappingZ:i.selfSnappingZ}),R),I(_,o,t,i)}doneSnapping(){this._removeVisualization(),this._resetSnappingState()}_selectUpdateInput({point:e,scenePoint:t}){switch(this._currentSnappedType){case 0:return e;case 1:return t}}_resetSnappingState(){this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=0}_removeVisualization(){this.removeHandles(R)}async _snapSinglePoint({point:e,context:t,signal:i}){const{view:n}=this,{elevationInfo:s}=t,a=y(e,n,s),r=await this._fetchCandidates(a,3,t,i);return this._createSnapResult(a,0,r,n,e,t,i)}async _snapMultiPoint({point:e,scenePoint:t,context:i,signal:n}){const{view:s}=this,{coordinateHelper:a,elevationInfo:r,spatialReference:o}=i;await at(t.spatialReference,o);const d=M(t,o),h=y(d,s,r),p=await this._fetchCandidates(h,1,i,n);if(p.length>0){const v=await this._fetchCandidates(h,2,i,n);return this._createSnapResult(h,1,[...p,...v],s,d,i,n)}const u=y(e,s,r),_=await this._fetchCandidates(u,2,i,n);return this._createSnapResult(u,0,_,s,{z:a.hasZ()&&e.hasZ?e.z??0:void 0,m:a.hasM()&&e.hasM?e.m??0:void 0},i,n)}async _fetchCandidates(e,t,i,n){return(await Promise.all(this._engines.map(s=>s.fetchCandidates(e,t,i,n)))).flat()}_createSnapResult(e,t,i,n,s,a,r){return{get valid(){return!rt(r)},apply:()=>{const{spatialReference:o}=a,{snappedPoint:d,hints:h}=this._processCandidates(e,t,i,a);return this._removeVisualization(),a.visualizer!=null&&this.addHandles(a.visualizer.draw(h,{spatialReference:o,elevationInfo:L,view:n,selfSnappingZ:a.selfSnappingZ}),R),I(d,n,s,a)}}}_processCandidates(e,t,i,n){if(i.length<1)return this.doneSnapping(),{snappedPoint:e,hints:[]};this._currentSnappedType!==t&&this._resetSnappingState(),_t(e,i);const s=this._currentMainCandidate;if(s!=null){const a=bt(s,i);if(a>=0){if(!(i[a]instanceof m))return this._intersectWithOtherCandidates(a,i,e,t,n);if(this._arePointsWithinScreenThreshold(e,s.targetPoint,n))return this._updateSnappingCandidate(s,t,i,n)}}return this._intersectWithOtherCandidates(0,i,e,t,n)}_intersectWithOtherCandidates(e,t,i,n,s){const{coordinateHelper:a}=s,r=t[e],o=[];for(let d=0;d<t.length;++d){if(d===e)continue;const h=t[d],p=r.constraint.intersect(h.constraint);if(p)for(const u of p.closestPoints(r.targetPoint))o.push([new m(x(u),r,h,h.isDraped),this._squaredScreenDistance(i,u,a)])}return o.length>0&&(o.sort((d,h)=>d[1]-h[1]),o[0][1]<this._squaredPointProximityThreshold(s.pointer))?this._updateSnappingCandidate(o[0][0],n,t,s):D(r,s.drawConstraints)?this._updateSnappingCandidate(r,n,t,s):{snappedPoint:i,hints:[]}}_updateSnappingCandidate(e,t,i,n){this.doneSnapping(),this._currentMainCandidate=e,this._currentSnappedType=t;const s=this._currentMainCandidate.targetPoint,a=[];a.push(...e.hints);for(const r of i){if(e instanceof m){if(r.constraint.equals(e.first.constraint)||r.constraint.equals(e.second.constraint))continue}else if(r.constraint.equals(e.constraint))continue;const o=r.constraint.closestTo(s);this._squaredScreenDistance(o,s,n.coordinateHelper)<Dt()&&(r.targetPoint=s,this._currentOtherActiveCandidates.push(r),a.push(...r.hints))}return{snappedPoint:s,hints:a}}_squaredPointProximityThreshold(e){return e==="touch"?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}_arePointsWithinScreenThreshold(e,t,i){return this._squaredScreenDistance(e,t,i.coordinateHelper)<this._squaredPointProximityThreshold(i.pointer)}_squaredScreenDistance(e,t,i){return St(this._toScreen(e,i),this._toScreen(t,i))}_toScreen(e,t){return Rt(e,t.spatialReference,L,this.view)}get test(){}};f([g({constructOnly:!0})],l.prototype,"view",void 0),f([g()],l.prototype,"options",void 0),f([g({readOnly:!0})],l.prototype,"updating",null),f([g()],l.prototype,"_loadTask",void 0),f([g()],l.prototype,"_engines",void 0),f([g()],l.prototype,"_squaredMouseProximityThreshold",null),f([g()],l.prototype,"_squaredTouchProximityThreshold",null),l=f([ot("esri.views.interactive.snapping.SnappingManager")],l);const R="visualization-handle";function Dt(){return H.satisfiesConstraintScreenThreshold*H.satisfiesConstraintScreenThreshold}function D(e,t){return!t||t.direction==null&&t.distance==null||!(e instanceof vt||e instanceof wt||e instanceof yt||e instanceof Pt||e instanceof Tt)&&(!(e instanceof mt)||t.direction==null&&e.selfSnappingType===1)}function bt(e,t){return e instanceof m?b(t,e.first)>=0&&b(t,e.second)>=0?0:-1:b(t,e)}function b(e,t){let i=-1;for(let n=0;n<e.length;++n)if(t.constraint.equals(e[n].constraint)){i=n;break}return i}function Lt(e){return e.scenePoint!=null}function qt({coordinateHelper:e,elevationInfo:t}){return e.hasZ()?L:t}export{wt as a,Z as b,kt as c,Ct as d,vt as e,Tt as f,Pt as h,yt as i,m as n,l as q,mt as r,Rt as s};
