import{aw as y,ax as u,ai as i,ay as d,az as v,aA as T,aB as f,aC as s,ar as n,aD as _,aE as h,aF as g,aG as l,aH as R,aI as x,aJ as m,aq as Z,aK as c,aL as z,aM as M,aN as w,aO as $}from"./index-Brd6-W-v.js";class V{constructor(t){this.spatialReference=t}createVector(){return this._tag(Z())}pointToVector(t){return this._tag(c(t.x,t.y))}arrayToVector(t){return this._tag(c(t[0],t[1]))}vectorToArray(t){return[t[0],t[1]]}pointToArray(t){return[t.x,t.y]}vectorToPoint(t,e=new i){if(t)return e.x=t[0],e.y=t[1],e.z=void 0,e.m=void 0,e.spatialReference=this.spatialReference,e}arrayToPoint(t,e=new i){return e.x=t[0],e.y=t[1],e.z=void 0,e.m=void 0,e.spatialReference=this.spatialReference,e}vectorToDehydratedPoint(t,e){if(t)return e??={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"},e.x=t[0],e.y=t[1],e.z=void 0,e.m=void 0,e.hasZ=!1,e.hasM=!1,e.spatialReference=this.spatialReference,e}lerp(t,e,a,r){return z(r,t,e,a)}addDelta(t,e,a){t[0]+=e,t[1]+=a}distance(t,e){return l(t,e)}getZ(t,e=void 0){return e}hasZ(){return!1}getM(t,e=void 0){return e}hasM(){return!1}clone(t){return this._tag(M(t))}copy(t,e){return w(e,t)}fromXYZ(t){return this._tag(c(t[0],t[1]))}toXYZ(t,e=n()){return s(e,t[0],t[1],0)}pointToXYZ(t,e=n()){return s(e,t.x,t.y,0)}equals(t,e){return $(t,e)}_tag(t){return t}}class p{constructor(t,e){this._valueType=t,this.spatialReference=e}createVector(){return this._tag(n())}pointToVector(t){return this._tag(h(t.x,t.y,this._valueType===0?t.z:t.m))}arrayToVector(t){return this._tag(h(t[0],t[1],t[2]||0))}vectorToArray(t){return[t[0],t[1],t[2]]}pointToArray(t){return this._valueType===0?[t.x,t.y,t.z]:[t.x,t.y,t.m]}vectorToPoint(t,e=new i){if(t)return e.x=t[0],e.y=t[1],e.z=this._valueType===0?t[2]:void 0,e.m=this._valueType===1?t[2]:void 0,e.spatialReference=this.spatialReference,e}arrayToPoint(t,e=new i){return e.x=t[0],e.y=t[1],e.z=this._valueType===0?t[2]:void 0,e.m=this._valueType===1?t[2]:void 0,e.spatialReference=this.spatialReference,e}vectorToDehydratedPoint(t,e){if(!t)return;e??={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"};const a=this._valueType===0,r=this._valueType===1;return e.x=t[0],e.y=t[1],e.z=a?t[2]:void 0,e.m=r?t[2]:void 0,e.hasZ=a,e.hasM=r,e.spatialReference=this.spatialReference,e}lerp(t,e,a,r){return g(r,t,e,a)}addDelta(t,e,a,r){t[0]+=e,t[1]+=a,this._valueType===0&&(t[2]+=r)}distance(t,e){return this._valueType===0?v(t,e):l(t,e)}getZ(t,e=void 0){return this._valueType===0?t[2]:e}hasZ(){return this._valueType===0}getM(t,e=void 0){return this._valueType===1?t[2]:e}hasM(){return this._valueType===1}clone(t){return this._tag(R(t))}copy(t,e){return x(e,t)}fromXYZ(t,e=0,a=0){return this._tag(h(t[0],t[1],this._valueType===0?t.length>2?t[2]:e:a))}toXYZ(t,e=n()){return s(e,t[0],t[1],this._valueType===0?t[2]:0)}pointToXYZ(t,e=n()){return s(e,t.x,t.y,this._valueType===0?t.z??0:0)}equals(t,e){return m(t,e)}_tag(t){return t}}class P{constructor(t){this.spatialReference=t}createVector(){return this._tag(y())}pointToVector(t){return this._tag(u(t.x,t.y,t.z,t.m))}arrayToVector(t){return this._tag(u(t[0],t[1],t[2]||0,t[3]||0))}vectorToArray(t){return[t[0],t[1],t[2],t[3]]}pointToArray(t){return[t.x,t.y,t.z,t.m]}vectorToPoint(t,e=new i){return e.x=t[0],e.y=t[1],e.z=t[2],e.m=t[3],e.spatialReference=this.spatialReference,e}arrayToPoint(t,e=new i){return e.x=t[0],e.y=t[1],e.z=t[2],e.m=t[3],e.spatialReference=this.spatialReference,e}vectorToDehydratedPoint(t,e){if(t)return e??={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"},e.x=t[0],e.y=t[1],e.z=t[2],e.m=t[3],e.hasZ=!0,e.hasM=!0,e.spatialReference=this.spatialReference,e}lerp(t,e,a,r){return d(r,t,e,a)}addDelta(t,e,a,r){t[0]+=e,t[1]+=a,t[2]+=r}distance(t,e){return v(t,e)}getZ(t){return t[2]}hasZ(){return!0}getM(t){return t[3]}hasM(){return!0}clone(t){return this._tag(T(t))}copy(t,e){return f(e,t)}fromXYZ(t,e=0,a=0){return this._tag(u(t[0],t[1],t.length>2?t[2]:e,a))}toXYZ(t,e=n()){return s(e,t[0],t[1],t[2])}pointToXYZ(t,e=n()){return s(e,t.x,t.y,t.z??0)}equals(t,e){return _(t,e)}_tag(t){return t}}function Y(o,t,e){return o&&t?new P(e):t?new p(1,e):o?new p(0,e):new V(e)}export{Y as w};
