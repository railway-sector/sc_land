import{bz as R,ad as w,a$ as x,b0 as z,ae as b}from"./index-CVzGOCNQ.js";import{j as I,w as P,h as $}from"./FeatureTemplates-BkkRmfJP.js";import{n as j,p as k}from"./createTemplateExecutor-COTtwtiQ.js";import{execute as Z}from"./affineTransformOperator-3JYdP7s9.js";import v from"./Transformation-7C1WgwNJ.js";import"./FeatureService-C87EUQvv.js";import"./applyEditsUtils-stzT1Xy5.js";import"./MeshTransform-D2izkyal.js";import"./editingSupport-Brqgmc_m.js";import"./utils-Cje67gBa.js";import"./Heading-DCecCONm.js";import"./SimpleGeometryCursor-B92kdZ15.js";import"./Point2D-8Py_srEd.js";import"./apiConverter-BzlOtf7d.js";import"./Envelope2D-DQ3Tn1o-.js";import"./ProjectionTransformation-KGXLRiS7.js";import"./Transformation2D-Ckyhe4wc.js";import"./OperatorDefinitions-DP7_WWTp.js";import"./jsonConverter-5JRjSyWN.js";function A({edits:t,geometry:r,mode:o,relationships:p,rotation:a,tag:i="",template:e}){const{definition:n}=e,s=r.x-n.origin.x,u=r.y-n.origin.y,d=n.origin.hasZ&&r.hasZ?r.z-n.origin.z:0,m=M(n.origin.clone(),s,u,d),h=new v().rotate(a,m.x,m.y);for(const y of n.parts){if(t.length>j&&o==="digitizing")break;const f=y.template;if(!I(f))throw new R("shared-template:template-not-loaded","A template part's template must be loaded before use");if(P(f)){let l=M(y.geometry,s,u,d);h.isIdentity()||(l=Z(l,h)),k({edits:t,geometry:l,relationships:p,tag:i,template:f})}else if($(f)){const l=[];if(A({edits:h.isIdentity()?l:t,geometry:r,mode:o,relationships:p,rotation:0,tag:i,template:f}),!h.isIdentity())for(const g of l){const{geometry:c}=g.graphic;c&&c.type!=="mesh"&&(g.graphic.geometry=Z(c,h),t.push(g))}}}return m}function M(t,r,o,p=0){if(!t)return null;if(t.type==="point")return new w({spatialReference:t.spatialReference,x:t.x+r,y:t.y+o,...t.hasZ?{z:t.z+p}:{},...t.hasM?{m:t.m}:{}});if(t.type==="multipoint"){const a=[];if(t.hasZ&&t.hasM)for(let i=0;i<t.points.length;i++){const e=t.points[i];a.push([e[0]+r,e[1]+o,e[2]+p,e[3]])}else if(t.hasZ)for(let i=0;i<t.points.length;i++){const e=t.points[i];a.push([e[0]+r,e[1]+o,e[2]+p])}else if(t.hasM)for(let i=0;i<t.points.length;i++){const e=t.points[i];a.push([e[0]+r,e[1]+o,e[2]])}else for(let i=0;i<t.points.length;i++){const e=t.points[i];a.push([e[0]+r,e[1]+o])}return new x({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM,points:a})}if(t.type==="polygon"){const a=new z({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM});for(let i=0;i<t.rings.length;i++){const e=t.rings[i],n=[];if(t.hasZ&&t.hasM)for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o,e[s][2]+p,e[s][3]]);else if(t.hasM)for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o,e[s][2]]);else if(t.hasZ)for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o,e[s][2]+p]);else for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o]);a.addRing(n)}return a}if(t.type==="polyline"){const a=new b({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM});for(let i=0;i<t.paths.length;i++){const e=t.paths[i],n=[];if(t.hasZ&&t.hasM)for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o,e[s][2]+p,e[s][3]]);else if(t.hasZ)for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o,e[s][2]+p]);else if(t.hasM)for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o,e[s][2]]);else for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o]);a.addPath(n)}return a}return t.clone()}export{A as createPresetServiceEdit,M as translate};
