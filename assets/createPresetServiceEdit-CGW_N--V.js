import{a4 as R,al as w,b4 as x,ae as z,ad as b}from"./index-BrQW8HOS.js";import{j as I,w as P,h as j}from"./FeatureTemplates-Y1q8_xKC.js";import{n as $,p as k}from"./createTemplateExecutor-C42KBRsu.js";import{execute as Z}from"./affineTransformOperator-BKNCSN4p.js";import v from"./Transformation-CXt5h21i.js";import"./FeatureService-DdnMPQJQ.js";import"./applyEditsUtils-Bdi3ieC8.js";import"./MeshTransform-wQhxY5y6.js";import"./editingSupport-5GkCZdaM.js";import"./utils-D5_eym7P.js";import"./Heading-Bx03M7LB.js";import"./symbolUtils-C3MaPSzp.js";import"./gfxUtils-DDSu4Luj.js";import"./cimSymbolUtils-CmFYUdpV.js";import"./svgUtils-BB2umWtg.js";import"./mat2df32-Dpt2CT5P.js";import"./mat2d-BbBq4Byx.js";import"./utils-6_NAbAK3.js";import"./vmEvent-CsrnYMSK.js";import"./substitute-D-eLZ17Q.js";import"./networkFieldUtils-CaYZrGFV.js";import"./SimpleGeometryCursor-B92kdZ15.js";import"./Point2D-DNXcsliy.js";import"./apiConverter---8F7iZ4.js";import"./Envelope2D-CUWyosZh.js";import"./ProjectionTransformation-BjD312Kq.js";import"./Transformation2D-BUBnKQZf.js";import"./OperatorDefinitions-DP7_WWTp.js";import"./jsonConverter-BHYd2kGf.js";function A({edits:t,geometry:r,mode:n,relationships:p,rotation:a,tag:s="",template:e}){const{definition:o}=e,i=r.x-o.origin.x,u=r.y-o.origin.y,d=o.origin.hasZ&&r.hasZ?r.z-o.origin.z:0,f=M(o.origin.clone(),i,u,d),h=new v().rotate(a,f.x,f.y);for(const y of o.parts){if(t.length>$&&n==="digitizing")break;const m=y.template;if(!I(m))throw new R("shared-template:template-not-loaded","A template part's template must be loaded before use");if(P(m)){let l=M(y.geometry,i,u,d);h.isIdentity()||(l=Z(l,h)),k({edits:t,geometry:l,relationships:p,tag:s,template:m})}else if(j(m)){const l=[];if(A({edits:h.isIdentity()?l:t,geometry:r,mode:n,relationships:p,rotation:0,tag:s,template:m}),!h.isIdentity())for(const g of l){const{geometry:c}=g.graphic;c&&c.type!=="mesh"&&(g.graphic.geometry=Z(c,h),t.push(g))}}}return f}function M(t,r,n,p=0){if(!t)return null;if(t.type==="point")return new w({spatialReference:t.spatialReference,x:t.x+r,y:t.y+n,...t.hasZ?{z:t.z+p}:{},...t.hasM?{m:t.m}:{}});if(t.type==="multipoint"){const a=[];if(t.hasZ&&t.hasM)for(let s=0;s<t.points.length;s++){const e=t.points[s];a.push([e[0]+r,e[1]+n,e[2]+p,e[3]])}else if(t.hasZ)for(let s=0;s<t.points.length;s++){const e=t.points[s];a.push([e[0]+r,e[1]+n,e[2]+p])}else if(t.hasM)for(let s=0;s<t.points.length;s++){const e=t.points[s];a.push([e[0]+r,e[1]+n,e[2]])}else for(let s=0;s<t.points.length;s++){const e=t.points[s];a.push([e[0]+r,e[1]+n])}return new x({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM,points:a})}if(t.type==="polygon"){const a=new z({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM});for(let s=0;s<t.rings.length;s++){const e=t.rings[s],o=[];if(t.hasZ&&t.hasM)for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n,e[i][2]+p,e[i][3]]);else if(t.hasM)for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n,e[i][2]]);else if(t.hasZ)for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n,e[i][2]+p]);else for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n]);a.addRing(o)}return a}if(t.type==="polyline"){const a=new b({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM});for(let s=0;s<t.paths.length;s++){const e=t.paths[s],o=[];if(t.hasZ&&t.hasM)for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n,e[i][2]+p,e[i][3]]);else if(t.hasZ)for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n,e[i][2]+p]);else if(t.hasM)for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n,e[i][2]]);else for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n]);a.addPath(o)}return a}return t.clone()}export{A as createPresetServiceEdit,M as translate};
