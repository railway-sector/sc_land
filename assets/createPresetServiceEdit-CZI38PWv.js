import{a5 as R,am as w,b5 as x,af as z,ae as b}from"./index-CgzAF5Ey.js";import{j as I,w as P,h as j}from"./FeatureTemplates-EkSMU26S.js";import{n as $,p as k}from"./createTemplateExecutor-CH3wJXeQ.js";import{execute as Z}from"./affineTransformOperator-CBep9xo8.js";import v from"./Transformation-CfjgNJxz.js";import"./FeatureService-CeU7iukh.js";import"./applyEditsUtils-Dnse8Gdk.js";import"./MeshTransform-Dit-XLCt.js";import"./editingSupport-DJtUgSza.js";import"./utils-705cvpPF.js";import"./Heading-CsXYN9Dx.js";import"./symbolUtils-0l5vVMbV.js";import"./gfxUtils-B1R76T6S.js";import"./cimSymbolUtils-D8zbHeXT.js";import"./svgUtils-smkwubCy.js";import"./mat2df32-Dpt2CT5P.js";import"./mat2d-DWPHXQcf.js";import"./utils-BxeCvIiv.js";import"./vmEvent-CsrnYMSK.js";import"./networkFieldUtils-CaYZrGFV.js";import"./SimpleGeometryCursor-B92kdZ15.js";import"./Point2D-8Py_srEd.js";import"./apiConverter-CvNJfrRe.js";import"./Envelope2D-DQ3Tn1o-.js";import"./ProjectionTransformation-D72vYhR2.js";import"./Transformation2D-Ckyhe4wc.js";import"./OperatorDefinitions-DP7_WWTp.js";import"./jsonConverter-EjytI4Do.js";function A({edits:t,geometry:r,mode:n,relationships:p,rotation:a,tag:s="",template:e}){const{definition:o}=e,i=r.x-o.origin.x,u=r.y-o.origin.y,y=o.origin.hasZ&&r.hasZ?r.z-o.origin.z:0,f=M(o.origin.clone(),i,u,y),h=new v().rotate(a,f.x,f.y);for(const d of o.parts){if(t.length>$&&n==="digitizing")break;const m=d.template;if(!I(m))throw new R("shared-template:template-not-loaded","A template part's template must be loaded before use");if(P(m)){let l=M(d.geometry,i,u,y);h.isIdentity()||(l=Z(l,h)),k({edits:t,geometry:l,relationships:p,tag:s,template:m})}else if(j(m)){const l=[];if(A({edits:h.isIdentity()?l:t,geometry:r,mode:n,relationships:p,rotation:0,tag:s,template:m}),!h.isIdentity())for(const g of l){const{geometry:c}=g.graphic;c&&c.type!=="mesh"&&(g.graphic.geometry=Z(c,h),t.push(g))}}}return f}function M(t,r,n,p=0){if(!t)return null;if(t.type==="point")return new w({spatialReference:t.spatialReference,x:t.x+r,y:t.y+n,...t.hasZ?{z:t.z+p}:{},...t.hasM?{m:t.m}:{}});if(t.type==="multipoint"){const a=[];if(t.hasZ&&t.hasM)for(let s=0;s<t.points.length;s++){const e=t.points[s];a.push([e[0]+r,e[1]+n,e[2]+p,e[3]])}else if(t.hasZ)for(let s=0;s<t.points.length;s++){const e=t.points[s];a.push([e[0]+r,e[1]+n,e[2]+p])}else if(t.hasM)for(let s=0;s<t.points.length;s++){const e=t.points[s];a.push([e[0]+r,e[1]+n,e[2]])}else for(let s=0;s<t.points.length;s++){const e=t.points[s];a.push([e[0]+r,e[1]+n])}return new x({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM,points:a})}if(t.type==="polygon"){const a=new z({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM});for(let s=0;s<t.rings.length;s++){const e=t.rings[s],o=[];if(t.hasZ&&t.hasM)for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n,e[i][2]+p,e[i][3]]);else if(t.hasM)for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n,e[i][2]]);else if(t.hasZ)for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n,e[i][2]+p]);else for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n]);a.addRing(o)}return a}if(t.type==="polyline"){const a=new b({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM});for(let s=0;s<t.paths.length;s++){const e=t.paths[s],o=[];if(t.hasZ&&t.hasM)for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n,e[i][2]+p,e[i][3]]);else if(t.hasZ)for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n,e[i][2]+p]);else if(t.hasM)for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n,e[i][2]]);else for(let i=0;i<e.length;i++)o.push([e[i][0]+r,e[i][1]+n]);a.addPath(o)}return a}return t.clone()}export{A as createPresetServiceEdit,M as translate};
