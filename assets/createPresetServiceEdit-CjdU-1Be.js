import{bI as R,ai as w,b4 as x,b5 as b,aj as z}from"./index-aRi8Xk-b.js";import{j as I,w as j,h as P}from"./FeatureTemplates-DtvIrCbc.js";import{n as $,p as k}from"./createTemplateExecutor-Bo0hr3wT.js";import{execute as Z}from"./affineTransformOperator-CYcPpYBN.js";import v from"./Transformation-B5QFC7mB.js";import"./FeatureService-CZrkB7iT.js";import"./applyEditsUtils-G1jadcUM.js";import"./MeshTransform-DL7voDcB.js";import"./editingSupport-ijVB5yKM.js";import"./utils-DnO-cM7Q.js";import"./Heading-CViwC7qz.js";import"./SimpleGeometryCursor-B92kdZ15.js";import"./Point2D-8Py_srEd.js";import"./apiConverter-FnkTMlaa.js";import"./Envelope2D-DQ3Tn1o-.js";import"./ProjectionTransformation-CepNZ9PX.js";import"./Transformation2D-Ckyhe4wc.js";import"./OperatorDefinitions-DP7_WWTp.js";import"./jsonConverter-BSFqafDe.js";function A({edits:t,geometry:r,mode:o,relationships:p,rotation:a,tag:i="",template:e}){const{definition:n}=e,s=r.x-n.origin.x,u=r.y-n.origin.y,y=n.origin.hasZ&&r.hasZ?r.z-n.origin.z:0,m=M(n.origin.clone(),s,u,y),h=new v().rotate(a,m.x,m.y);for(const d of n.parts){if(t.length>$&&o==="digitizing")break;const f=d.template;if(!I(f))throw new R("shared-template:template-not-loaded","A template part's template must be loaded before use");if(j(f)){let l=M(d.geometry,s,u,y);h.isIdentity()||(l=Z(l,h)),k({edits:t,geometry:l,relationships:p,tag:i,template:f})}else if(P(f)){const l=[];if(A({edits:h.isIdentity()?l:t,geometry:r,mode:o,relationships:p,rotation:0,tag:i,template:f}),!h.isIdentity())for(const g of l){const{geometry:c}=g.graphic;c&&c.type!=="mesh"&&(g.graphic.geometry=Z(c,h),t.push(g))}}}return m}function M(t,r,o,p=0){if(!t)return null;if(t.type==="point")return new w({spatialReference:t.spatialReference,x:t.x+r,y:t.y+o,...t.hasZ?{z:t.z+p}:{},...t.hasM?{m:t.m}:{}});if(t.type==="multipoint"){const a=[];if(t.hasZ&&t.hasM)for(let i=0;i<t.points.length;i++){const e=t.points[i];a.push([e[0]+r,e[1]+o,e[2]+p,e[3]])}else if(t.hasZ)for(let i=0;i<t.points.length;i++){const e=t.points[i];a.push([e[0]+r,e[1]+o,e[2]+p])}else if(t.hasM)for(let i=0;i<t.points.length;i++){const e=t.points[i];a.push([e[0]+r,e[1]+o,e[2]])}else for(let i=0;i<t.points.length;i++){const e=t.points[i];a.push([e[0]+r,e[1]+o])}return new x({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM,points:a})}if(t.type==="polygon"){const a=new b({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM});for(let i=0;i<t.rings.length;i++){const e=t.rings[i],n=[];if(t.hasZ&&t.hasM)for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o,e[s][2]+p,e[s][3]]);else if(t.hasM)for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o,e[s][2]]);else if(t.hasZ)for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o,e[s][2]+p]);else for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o]);a.addRing(n)}return a}if(t.type==="polyline"){const a=new z({spatialReference:t.spatialReference,hasZ:t.hasZ,hasM:t.hasM});for(let i=0;i<t.paths.length;i++){const e=t.paths[i],n=[];if(t.hasZ&&t.hasM)for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o,e[s][2]+p,e[s][3]]);else if(t.hasZ)for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o,e[s][2]+p]);else if(t.hasM)for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o,e[s][2]]);else for(let s=0;s<e.length;s++)n.push([e[s][0]+r,e[s][1]+o]);a.addPath(n)}return a}return t.clone()}export{A as createPresetServiceEdit,M as translate};
