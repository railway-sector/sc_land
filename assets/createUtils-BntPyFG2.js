import{fm as N,fn as Q,fo as q,aQ as U,aP as _,bB as A,ae as C,fp as D,fq as v,ad as G,b4 as H,al as J,aF as K,ar as E}from"./index-BrQW8HOS.js";import{b as O}from"./Circle-CDzQBXRC.js";import{c as S}from"./distanceOperator-BeiDdpLt.js";import{c as V,u as W}from"./simplifyOperator-BQVvn5Fy.js";import{w as s}from"./surfaceCoordinateSystems-BrNYf00T.js";function d(r,a){const o=new J({x:r[0],y:r[1],spatialReference:a});return r.length>2&&(o.z=r[2]),o}function na(r,a){return new H({points:r,spatialReference:a})}function ea(r,a,o){const e=new G({paths:r,spatialReference:a});return o&&v(e),e}function z(r,a,o,e=!0){const l=_(r);l.forEach(n=>{const i=n[0],c=n[n.length-1];A(i,c)&&n.length!==1||n.push(n[0])});let t=new C({rings:l,spatialReference:a});return t.rings.forEach(n=>{D(n)||n.reverse()}),o&&v(t),e&&!V(t)&&q(a)&&(t=W(t)||t),t}function la(r,a,o){const e=a.mapToLocalMultiple(r),l=[],t={x:e[0].x,y:e[0].y},n={x:e[1].x,y:e[1].y},i=Math.round(n.x-t.x),c=Math.round(n.y-t.y),x=Math.max(Math.abs(i),Math.abs(c));if(o){const u={x:t.x+x,y:t.y+x},f={x:t.x-x,y:t.y-x};l.push(s(u.x,f.y),s(f.x,f.y),s(f.x,u.y),s(u.x,u.y))}else{const u={x:i>0?t.x+x:t.x-x,y:c>0?t.y+x:t.y-x};l.push(s(t.x,t.y),s(u.x,t.y),s(u.x,u.y),s(t.x,u.y))}return k(z([l.map(u=>a.localToMap(u)).filter(U)],a.spatialReference,a.doUnnormalization,!0),l,a)}function oa(r,a,o){let e=a.mapToLocalMultiple(r);if(e.length===1){const c=e[0];e=[s(c.x-48,c.y+48),s(c.x+48,c.y-48),s(c.x+48,c.y-48),s(c.x-48,c.y+48)]}const l=[],t={x:e[0].x,y:e[0].y},n={x:e[1].x,y:e[1].y};if(o){const i=Math.round(n.x-t.x),c=Math.round(n.y-t.y);l.push(s(t.x-i,t.y-c),s(n.x,t.y-c),s(n.x,n.y),s(t.x-i,n.y))}else l.push(s(t.x,t.y),s(n.x,t.y),s(n.x,n.y),s(t.x,n.y));return k(z([l.map(i=>a.localToMap(i)).filter(U)],a.spatialReference,a.doUnnormalization,!0),l,a)}function k(r,a,o){const e=w(a[3],a[2],o),l=w(a[1],a[2],o),t=w(a[0],a[1],o),n=w(a[0],a[3],o);return{geometry:r,midpoints:e!=null&&l!=null&&t!=null&&n!=null?{top:e,right:l,bottom:t,left:n}:null}}function w(r,a,o){T[0]=r.x,T[1]=r.y,T[2]=0,g[0]=a.x,g[1]=a.y,g[2]=0,K(T,T,g,.5),P.x=T[0],P.y=g[1],P.z=g[2];const e=o.localToMap(P);return e!=null?d(e,o.spatialReference):null}const P=s(0,0,0),T=E(),g=E();function sa(r,a,o,e){const l=a.mapToLocalMultiple(r);let t=null,n=null;if(o)t=l[0],n=l[1];else{const p=l[0],y=l[1],R=Math.round(y.x-p.x),b=Math.round(y.y-p.y),h=Math.max(Math.abs(R),Math.abs(b));t=s(R>0?p.x+h/2:p.x-h/2,b>0?p.y+h/2:p.y-h/2),n=s(Math.abs(R)>Math.abs(b)?t.x-h/2:t.x,Math.abs(R)>Math.abs(b)?t.y:t.y-h/2)}const i=a.localToMap(t),c=a.localToMap(n);if(i==null||c==null)return null;a.doUnnormalization&&N([[i,c]],a.spatialReference);const x=d(i,a.spatialReference),u=d(c,a.spatialReference),f=Q(a.spatialReference);let M=0;if(q(a.spatialReference))M=f*S(x,u);else{const p=t.x-n.x,y=t.y-n.y;M=f*Math.sqrt(p*p+y*y)*(e||1)}const $=new O({center:x,radius:M,radiusUnit:"meters",spatialReference:a.spatialReference});return{geometry:z($.rings,$.spatialReference,!1),center:x,edge:u}}function ra(r,a,o){const e=a.mapToLocalMultiple(r),l=e[0],t=e[1],n=Math.round(t.x-l.x),i=Math.round(t.y-l.y),c=s(o?l.x:l.x+n/2,o?l.y:l.y+i/2),x=o?n:n/2,u=o?i:i/2,f=60,M=[],$=2*Math.PI/f;function p(m){const B=Math.cos(m),F=Math.sin(m);return s(x*B+c.x,u*F+c.y)}for(let m=0;m<f;m++)M.push(p(m*$));M.push(M[0]);const{spatialReference:y,doUnnormalization:R}=a,b=z([M.map(m=>a.localToMap(m)).filter(U)],y,R,!1),h=a.localToMap(p(Math.PI/2)),I=a.localToMap(p(0)),L=a.localToMap(p(-Math.PI/2)),j=a.localToMap(p(Math.PI));return{geometry:b,midpoints:h!=null&&I!=null&&L!=null&&j!=null?{top:d(h,y),right:d(I,y),bottom:d(L,y),left:d(j,y)}:null}}export{na as R,z as T,oa as U,la as b,ea as j,sa as k,ra as v};
