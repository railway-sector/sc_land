import{a5 as F,aQ as z,fn as G,fE as I,uB as B,b0 as U,ds as M,p8 as J,iJ as W,gO as K,uC as X,uD as Y,b4 as ee,fe as te,j1 as ne}from"./index-BrQW8HOS.js";import{M as le,o as se,B as ae,e as O,y as ie,t as oe}from"./elevationProfileGeometryUtils-u3tjjsiT.js";let k={noDataValue:-5e5,defaultQueryOptions:()=>({noDataValue:k.noDataValue,demResolution:"auto",maximumAutoTileRequests:150,ignoreInvisibleLayers:!0,signal:null}),updateThrottleMillis:100,delayAfterPreviewMillis:500,defaultDemResolution:F(10,"centimeters","meters"),densificationMaxSamples:3e3,largeChartSamples:1e4,maxTotalSamples:1e5,maxChartRatio:300,minSlopeSampleDistance:10,formatPrecision:1,profileLinesUpdateThrottleMillis:100,hoveredPointsStyle:{size:14,borderStyle:"solid",borderWidth:3,borderColor:"#ffffff",boxShadow:"0px 0px 0px 5px rgba(255,255,255,0.2)"}};function N(){return k}const re={progress:1,hasZ:!1,samples:[],statistics:null,spatialReference:null},Ee=" â€• ";function ue(t,e){const n=t.length;if(n===0)return null;const l=t[0],s=l.sampledZ;let i=s,a=s,o=0,u=0,r=null,c=null,d=s??0,p=0,m=0,v=s!=null?1:0,x=0,f=0;const h=G(e),_=I(e),$=N().minSlopeSampleDistance/h,q=2*$,P=new L,y=new L,b=()=>{Q(),P.copy(y),y.reset()},A=(g,Z)=>{b(),g>0&&g-P.start<=q&&(g=P.start+$),y.restart(g,Z)},Q=()=>{if(P.isHole||y.isHole)return;const g=y.avgElevation-P.avgElevation,Z=y.start-P.start,R=g*_,w=Z*h,E=F(Math.atan2(R,w),"radians","degrees");E>0?(p+=E,r=S(r,E),x++):E<0&&(m-=E,c=S(c,-E),f++)};l.sampledZ!=null&&A(l.distance,l.sampledZ);for(let g=1;g<n;++g){const Z=t[g-1],R=t[g],w=R.sampledZ;if(w==null){y.isHole||b();continue}v++,d+=w,i=T(i,w),a=S(a,w),y.isHole||R.distance-y.start>=$?A(R.distance,w):y.insert(w);const E=Z.sampledZ;if(E!=null){const D=w-E;D>0?o+=D:D<0&&(u-=D)}}return b(),v===0?null:{maxDistance:t[n-1].distance,minElevation:i,maxElevation:a,avgElevation:v===0?null:d/v,elevationGain:o,elevationLoss:u,maxPositiveSlope:r,maxNegativeSlope:c,avgPositiveSlope:x===0?null:p/x,avgNegativeSlope:f===0?null:m/f}}function Se(t){const e=t.filter(z),n=e.length;if(n===0)return null;const l=e[0];if(n===1)return l;let s=l.maxDistance,i=l.minElevation,a=l.maxElevation,o=l.maxPositiveSlope,u=l.maxNegativeSlope;for(let r=1;r<e.length;++r){const c=e[r];s=S(s,c.maxDistance),i=T(i,c.minElevation),a=S(a,c.maxElevation),o=S(o,c.maxPositiveSlope),u=S(u,c.maxNegativeSlope)}return{maxDistance:s,minElevation:i,maxElevation:a,avgElevation:null,elevationGain:null,elevationLoss:null,maxPositiveSlope:o,maxNegativeSlope:u,avgPositiveSlope:null,avgNegativeSlope:null}}function _e(t){let e=null,n=null,l=null;for(const s of t){if(s==null)continue;const{statistics:i,spatialReference:a}=s;if(i==null)continue;const o=G(a);e=S(e,C(i.maxDistance,o));const u=I(a);l=T(l,C(i.minElevation,u)),n=S(n,C(i.maxElevation,u))}return{minDistance:0,maxDistance:e??0,minElevation:l??0,maxElevation:n??0}}function T(t,e){return e==null?t:t!=null?Math.min(t,e):e}function S(t,e){return e==null?t:t!=null?Math.max(t,e):e}function C(t,e){return t!=null&&e!=null?t*e:null}class L{constructor(){this._start=0,this._totalElevation=0,this._sampleCount=0}get avgElevation(){return this._totalElevation/this._sampleCount}get isHole(){return this._sampleCount===0}get start(){return this._start}copy(e){this._start=e._start,this._sampleCount=e._sampleCount,this._totalElevation=e._totalElevation}reset(){this._start=0,this._sampleCount=0,this._totalElevation=0}restart(e,n){this._start=e,this._sampleCount=1,this._totalElevation=n}insert(e){++this._sampleCount,this._totalElevation+=e}}function ce(t,e,n=[]){if(t>=e||(n.push(t),e-t<2))return n;const l=e-1;n.push(l);const s=H(t+1,l);for(;;){const i=s.next();if(i.done)break;n.push(i.value)}return n}function*H(t,e){if(t>=e)return;const n=t+Math.floor((e-t)/2);yield n;const l=H(t,n),s=H(n+1,e);for(;;){const i=l.next(),a=s.next();if(i.done&&a.done)break;i.done||(yield i.value),a.done||(yield a.value)}}async function*Pe(t,e){const{view:n,geometry:l,elevationInfo:s,providers:i,options:a}=t,o=n.spatialReference;if(!o||l==null||!le(l))throw new se;const u=i.length;if(u===0)return null;const r=Math.round(a.maxTotalSamples/u);if(ae(l)>r)throw new O;const c=await ie(l,s,n,o,a,r,e);M(e);let d=0;const p=new Array(u),m=new Array(u);for(let f=0;f<u;f++){const h=he(c);p[f]=h,d+=h.samples.length;const _={...t,provider:i[f],result:h,densificationResult:c};m[f]=fe(_,e)[Symbol.iterator]()}if(d>a.maxTotalSamples)throw new O;const v=await Promise.all(m.map(f=>{const h=f.next();return h.done===!0?Promise.resolve(null):h.value}));M(e);for(let f=0;f<u;f++)p[f]=v[f];yield p,await W(t.delayAfterPreview??N().delayAfterPreviewMillis,null,e.signal),M(e);const x=[];try{let f;do{f=!1;for(let h=0;h<u;h++){const _=m[h].next();_.done===!1&&(x.push({resultPromise:_.value,index:h}),f=!0)}}while(f)}finally{m.forEach(f=>f.return?.())}for(const{resultPromise:f,index:h}of x)p[h]=await f,M(e),yield p;for(const f of p)f!=null&&(f.progress=1);yield p}function*fe(t,e){const{densificationResult:n}=t,l={...t,abortOptions:e,densificationResult:n},s=ce(0,l.result.samples.length),i=s.slice(0,l.provider.numSamplesForPreview);yield V(l,i,!0);const a=Y(s,l.provider.numSamplesPerChunk);for(const o of a)yield V(l,o,!1)}async function V({densificationResult:t,result:e,provider:n,queue:l,abortOptions:s,cache:i},a,o){const{densifiedPath:u,pathLength:r}=t,c=e.spatialReference,{samples:d}=e,p=[];for(let m=0;m<a.length;m++){const v=d[a[m]];p[m]=[...v.coordinate]}try{return await l.push({geometry:new ee({spatialReference:c,points:p,hasZ:u.hasZ}),provider:n,indices:a,preview:o,result:e,parameters:{...N().defaultQueryOptions(),minDemResolution:Math.round(o?r/n.numSamplesForPreview:r/d.length),cache:i}},s),{...e}}catch(m){return te(m)?null:re}}function Ze(t){return new B({priority:U.ELEVATION_PROFILE,concurrency:1,scheduler:t,process:async e=>{M(e.parameters);try{await pe(e)}catch(n){J(n)}}})}async function pe({geometry:t,provider:e,indices:n,preview:l,result:s,parameters:i}){if(n.length===0)return;const a=(await xe(e,t,i)).geometry,{hasZ:o,points:u}=a,r=i.noDataValue,{samples:c}=s;for(let d=0;d<n.length;d++){const p=c[n[d]];if(p.isHole)continue;const m=o?u[d][2]:null;m===null||m===r?p.sampledZ=null:(s.hasZ=!0,p.sampledZ=m),p.sampled=!0}me(c),s.progress=l?0:s.progress+n.length/c.length,s.statistics=ue(s.samples,s.spatialReference)}function me(t){const e=t.length-1;let n=0;for(let l=1;l<=e;l++)(t[l].sampled||l===e)&&(de(t,n,l),n=l)}function de(t,e,n){if(n-e===1)return;const l=t[e],s=l.sampledZ,i=t[n],a=i.sampledZ;if(s==null||a==null){for(let r=e+1;r<n;r++)t[r].sampledZ=null;return}const o=l.distance,u=i.distance-o;for(let r=e+1;r<n;r++){const c=t[r],d=(c.distance-o)/u;c.sampledZ=ne(s,a,d)}}function he({densifiedPath:t,distances:e}){const n=t.spatialReference,l=K(n),s=t.paths,i=s.length,a=[];let o=null,u=0;for(let r=0;r<i;r++){const c=s[r],d=c.length,p=e[r];for(let m=0;m<d;m++){const v=c[m],x=p[m];l&&(v[0]=X(v[0],l.valid[0],l.valid[1])),o&&m===0&&ve(a,o,v,u,x),a.push(ge(v,x)),o=v,u=x}}return{progress:0,samples:a,hasZ:!1,statistics:null,spatialReference:n}}function ve(t,e,n,l,s){t.push(j(e,l)),t.push(j(n,s))}function ge(t,e){return{coordinate:t,distance:e,sampledZ:null,sampled:!1,isHole:!1}}function j(t,e){return{coordinate:t,distance:e,sampledZ:null,sampled:!0,isHole:!0}}async function xe(t,e,n){try{return await t.queryElevation(e,n)}catch{throw new oe}}function Re(t,e,n){if(!t||t.length===0)return;const l=t.length-1,s=t[0];if(e<=n(s))return s;const i=t[l];if(e>=n(i))return i;let a=0,o=0,u=l;for(;a<u;){o=a+Math.floor((u-a)/2);const r=t[o],c=n(r);if(c===e)return r;if(e<c){if(o>0){const d=t[o-1],p=n(d);if(e>p)return e-p>=c-e?r:d}u=o}else{if(o<l){const d=t[o+1],p=n(d);if(e<p)return e-c>=p-e?d:r}a=o+1}}return t[o]}function Me(t){return t>.999999?1:t}export{Re as F,Me as H,Ze as S,_e as a,N as i,Pe as j,Se as o,Ee as s};
