import{eX as q,aP as Q,eM as F,f3 as I,uq as U,b0 as B,d1 as R,oy as W,iG as X,g0 as J,ur as K,us as Y,b4 as ee,ez as te,hN as ne}from"./index-aRi8Xk-b.js";import{M as le,o as se,B as ae,e as L,y as ie,t as oe}from"./elevationProfileGeometryUtils-DsGF4lJZ.js";let j={noDataValue:-5e5,defaultQueryOptions:()=>({noDataValue:j.noDataValue,demResolution:"auto",maximumAutoTileRequests:150,ignoreInvisibleLayers:!0,signal:null}),updateThrottleMillis:100,delayAfterPreviewMillis:500,defaultDemResolution:q(10,"centimeters","meters"),densificationMaxSamples:3e3,largeChartSamples:1e4,maxTotalSamples:1e5,maxChartRatio:300,minSlopeSampleDistance:10,formatPrecision:1,profileLinesUpdateThrottleMillis:100,hoveredPointsStyle:{size:14,borderStyle:"solid",borderWidth:3,borderColor:"#ffffff",boxShadow:"0px 0px 0px 5px rgba(255,255,255,0.2)"}};function H(){return j}const re={progress:1,hasZ:!1,samples:[],statistics:null,spatialReference:null},Ee=" â€• ";function ue(t,e){const n=t.length;if(n===0)return null;const l=t[0],s=l.sampledZ;let i=s,a=s,o=0,u=0,r=null,c=null,d=s??0,m=0,p=0,v=s!=null?1:0,x=0,f=0;const h=F(e),P=I(e),D=H().minSlopeSampleDistance/h,k=2*D,_=new O,y=new O,b=()=>{z(),_.copy(y),y.reset()},A=(g,Z)=>{b(),g>0&&g-_.start<=k&&(g=_.start+D),y.restart(g,Z)},z=()=>{if(_.isHole||y.isHole)return;const g=y.avgElevation-_.avgElevation,Z=y.start-_.start,M=g*P,w=Z*h,E=q(Math.atan2(M,w),"radians","degrees");E>0?(m+=E,r=S(r,E),x++):E<0&&(p-=E,c=S(c,-E),f++)};l.sampledZ!=null&&A(l.distance,l.sampledZ);for(let g=1;g<n;++g){const Z=t[g-1],M=t[g],w=M.sampledZ;if(w==null){y.isHole||b();continue}v++,d+=w,i=T(i,w),a=S(a,w),y.isHole||M.distance-y.start>=D?A(M.distance,w):y.insert(w);const E=Z.sampledZ;if(E!=null){const $=w-E;$>0?o+=$:$<0&&(u-=$)}}return b(),v===0?null:{maxDistance:t[n-1].distance,minElevation:i,maxElevation:a,avgElevation:v===0?null:d/v,elevationGain:o,elevationLoss:u,maxPositiveSlope:r,maxNegativeSlope:c,avgPositiveSlope:x===0?null:m/x,avgNegativeSlope:f===0?null:p/f}}function Se(t){const e=t.filter(Q),n=e.length;if(n===0)return null;const l=e[0];if(n===1)return l;let s=l.maxDistance,i=l.minElevation,a=l.maxElevation,o=l.maxPositiveSlope,u=l.maxNegativeSlope;for(let r=1;r<e.length;++r){const c=e[r];s=S(s,c.maxDistance),i=T(i,c.minElevation),a=S(a,c.maxElevation),o=S(o,c.maxPositiveSlope),u=S(u,c.maxNegativeSlope)}return{maxDistance:s,minElevation:i,maxElevation:a,avgElevation:null,elevationGain:null,elevationLoss:null,maxPositiveSlope:o,maxNegativeSlope:u,avgPositiveSlope:null,avgNegativeSlope:null}}function Pe(t){let e=null,n=null,l=null;for(const s of t){if(s==null)continue;const{statistics:i,spatialReference:a}=s;if(i==null)continue;const o=F(a);e=S(e,C(i.maxDistance,o));const u=I(a);l=T(l,C(i.minElevation,u)),n=S(n,C(i.maxElevation,u))}return{minDistance:0,maxDistance:e??0,minElevation:l??0,maxElevation:n??0}}function T(t,e){return e==null?t:t!=null?Math.min(t,e):e}function S(t,e){return e==null?t:t!=null?Math.max(t,e):e}function C(t,e){return t!=null&&e!=null?t*e:null}class O{constructor(){this._start=0,this._totalElevation=0,this._sampleCount=0}get avgElevation(){return this._totalElevation/this._sampleCount}get isHole(){return this._sampleCount===0}get start(){return this._start}copy(e){this._start=e._start,this._sampleCount=e._sampleCount,this._totalElevation=e._totalElevation}reset(){this._start=0,this._sampleCount=0,this._totalElevation=0}restart(e,n){this._start=e,this._sampleCount=1,this._totalElevation=n}insert(e){++this._sampleCount,this._totalElevation+=e}}function ce(t,e,n=[]){if(t>=e||(n.push(t),e-t<2))return n;const l=e-1;n.push(l);const s=N(t+1,l);for(;;){const i=s.next();if(i.done)break;n.push(i.value)}return n}function*N(t,e){if(t>=e)return;const n=t+Math.floor((e-t)/2);yield n;const l=N(t,n),s=N(n+1,e);for(;;){const i=l.next(),a=s.next();if(i.done&&a.done)break;i.done||(yield i.value),a.done||(yield a.value)}}async function*_e(t,e){const{view:n,geometry:l,elevationInfo:s,providers:i,options:a}=t,o=n.spatialReference;if(!o||l==null||!le(l))throw new se;const u=i.length;if(u===0)return null;const r=Math.round(a.maxTotalSamples/u);if(ae(l)>r)throw new L;const c=await ie(l,s,n,o,a,r,e);R(e);let d=0;const m=new Array(u),p=new Array(u);for(let f=0;f<u;f++){const h=he(c);m[f]=h,d+=h.samples.length;const P={...t,provider:i[f],result:h,densificationResult:c};p[f]=fe(P,e)[Symbol.iterator]()}if(d>a.maxTotalSamples)throw new L;const v=await Promise.all(p.map(f=>{const h=f.next();return h.done===!0?Promise.resolve(null):h.value}));R(e);for(let f=0;f<u;f++)m[f]=v[f];yield m,await X(t.delayAfterPreview??H().delayAfterPreviewMillis,null,e.signal),R(e);const x=[];try{let f;do{f=!1;for(let h=0;h<u;h++){const P=p[h].next();P.done===!1&&(x.push({resultPromise:P.value,index:h}),f=!0)}}while(f)}finally{p.forEach(f=>f.return?.())}for(const{resultPromise:f,index:h}of x)m[h]=await f,R(e),yield m;for(const f of m)f!=null&&(f.progress=1);yield m}function*fe(t,e){const{densificationResult:n}=t,l={...t,abortOptions:e,densificationResult:n},s=ce(0,l.result.samples.length),i=s.slice(0,l.provider.numSamplesForPreview);yield G(l,i,!0);const a=Y(s,l.provider.numSamplesPerChunk);for(const o of a)yield G(l,o,!1)}async function G({densificationResult:t,result:e,provider:n,queue:l,abortOptions:s,cache:i},a,o){const{densifiedPath:u,pathLength:r}=t,c=e.spatialReference,{samples:d}=e,m=[];for(let p=0;p<a.length;p++){const v=d[a[p]];m[p]=[...v.coordinate]}try{return await l.push({geometry:new ee({spatialReference:c,points:m,hasZ:u.hasZ}),provider:n,indices:a,preview:o,result:e,parameters:{...H().defaultQueryOptions(),minDemResolution:Math.round(o?r/n.numSamplesForPreview:r/d.length),cache:i}},s),{...e}}catch(p){return te(p)?null:re}}function Ze(t){return new U({priority:B.ELEVATION_PROFILE,concurrency:1,scheduler:t,process:async e=>{R(e.parameters);try{await me(e)}catch(n){W(n)}}})}async function me({geometry:t,provider:e,indices:n,preview:l,result:s,parameters:i}){if(n.length===0)return;const a=(await xe(e,t,i)).geometry,{hasZ:o,points:u}=a,r=i.noDataValue,{samples:c}=s;for(let d=0;d<n.length;d++){const m=c[n[d]];if(m.isHole)continue;const p=o?u[d][2]:null;p===null||p===r?m.sampledZ=null:(s.hasZ=!0,m.sampledZ=p),m.sampled=!0}pe(c),s.progress=l?0:s.progress+n.length/c.length,s.statistics=ue(s.samples,s.spatialReference)}function pe(t){const e=t.length-1;let n=0;for(let l=1;l<=e;l++)(t[l].sampled||l===e)&&(de(t,n,l),n=l)}function de(t,e,n){if(n-e===1)return;const l=t[e],s=l.sampledZ,i=t[n],a=i.sampledZ;if(s==null||a==null){for(let r=e+1;r<n;r++)t[r].sampledZ=null;return}const o=l.distance,u=i.distance-o;for(let r=e+1;r<n;r++){const c=t[r],d=(c.distance-o)/u;c.sampledZ=ne(s,a,d)}}function he({densifiedPath:t,distances:e}){const n=t.spatialReference,l=J(n),s=t.paths,i=s.length,a=[];let o=null,u=0;for(let r=0;r<i;r++){const c=s[r],d=c.length,m=e[r];for(let p=0;p<d;p++){const v=c[p],x=m[p];l&&(v[0]=K(v[0],l.valid[0],l.valid[1])),o&&p===0&&ve(a,o,v,u,x),a.push(ge(v,x)),o=v,u=x}}return{progress:0,samples:a,hasZ:!1,statistics:null,spatialReference:n}}function ve(t,e,n,l,s){t.push(V(e,l)),t.push(V(n,s))}function ge(t,e){return{coordinate:t,distance:e,sampledZ:null,sampled:!1,isHole:!1}}function V(t,e){return{coordinate:t,distance:e,sampledZ:null,sampled:!0,isHole:!0}}async function xe(t,e,n){try{return await t.queryElevation(e,n)}catch{throw new oe}}function Me(t,e,n){if(!t||t.length===0)return;const l=t.length-1,s=t[0];if(e<=n(s))return s;const i=t[l];if(e>=n(i))return i;let a=0,o=0,u=l;for(;a<u;){o=a+Math.floor((u-a)/2);const r=t[o],c=n(r);if(c===e)return r;if(e<c){if(o>0){const d=t[o-1],m=n(d);if(e>m)return e-m>=c-e?r:d}u=o}else{if(o<l){const d=t[o+1],m=n(d);if(e<m)return e-c>=m-e?d:r}a=o+1}}return t[o]}function Re(t){return t>.999999?1:t}export{Me as F,Re as H,Ze as S,Pe as a,H as i,_e as j,Se as o,Ee as s};
