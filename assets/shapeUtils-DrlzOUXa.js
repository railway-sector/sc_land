import{ad as v,bB as q,al as R,os as Z,aH as w}from"./index-BrQW8HOS.js";import{u as B,y as g,a as H,e as b,p as _}from"./customElement-aPQS1Oaw.js";function A(a){let n=0;const r=B(a.spatialReference);for(let t=0;t<a.paths.length;t++){const c=a.paths[t].length;for(let h=0;h<c;h++)h>0&&(n+=a.hasZ?g(a.paths[t][h-1],a.paths[t][h],r):Z(a.paths[t][h-1],a.paths[t][h]))}return n}function C(a){const n=a.geometry.clone();return n.paths.map(r=>new v({spatialReference:a.geometry.spatialReference,paths:[r],hasZ:n.hasZ,hasM:n.hasM}))}function D(a){const n=[];for(const r of a.paths)for(let t=1;t<r.length;t++){const c=[[r[t-1].slice(),r[t].slice()]];n.push(new v({paths:c,spatialReference:a.spatialReference,hasZ:a.hasZ,hasM:a.hasM}))}return n}function d(a,n,r){const t=n[0],c=n[1],h=Z(t,c),f=a.x+r*((n[1][0]-n[0][0])/h),o=a.y+r*((n[1][1]-n[0][1])/h),p={};return a.hasM&&(p.m=a.m),new R({x:f,y:o,spatialReference:a.spatialReference,...p})}function z(a,n,r,t){const c=n[0],h=n[1],f=g(c,h,t),o=a.x+r*((n[1][0]-n[0][0])/f),p=a.y+r*((n[1][1]-n[0][1])/f),l=a.z+r*((n[1][2]-n[0][2])/f),e={};return a.hasM&&(e.m=a.m),new R({x:o,y:p,z:l,spatialReference:a.spatialReference,...e})}function u(a,n,r){const t=n[0],c=n[1],h=[c[0]-t[0],c[1]-t[1]],f=Math.sqrt(h[0]**2+h[1]**2),o=[h[0]/f,h[1]/f];return a.x+=r*o[0],a.y+=r*o[1],a}function E(a,n,r){let t=0,c=null;if(n<=0){const e=[a.paths[0][0],a.paths[0][1]];let s=M(a,0,0);return s=d(s,e,n),u(s,e,r)}const h=a.hasM?a.hasZ?3:2:-1;for(const e of a.paths)for(let s=0;s<e.length-1;s++){const m=Z(e[s],e[s+1]),y=t+m;if(y===n)return c=new R({x:e[s+1][0],y:e[s+1][1],...a.hasM?{m:e[s+1][h]}:{},spatialReference:a.spatialReference}),r===0?c:u(c,[e[s],e[s+1]],r);if(y>n){const i=_(e[s],e[s+1],n-t);return c=new R({x:i[0],y:i[1],...h>-1?{m:b(e[s][h],e[s+1][h],m,n-t)??void 0}:{},spatialReference:a.spatialReference}),r===0?c:u(c,[e[s],e[s+1]],r)}t+=m}if(t===0)return null;const f=a.paths.length-1,o=a.paths[f].length-1,p=[a.paths[f][o-1],a.paths[f][o]];let l=M(a,f,o);return l=d(l,p,n-t),u(l,p,r)}function F(a,n,r,t){let c=0;if(n<=0){const e=[a.paths[0][0],a.paths[0][1]];let s=M(a,0,0);return s=z(s,e,n,t),u(s,e,r)}const h=a.hasM?a.hasZ?3:2:-1;for(const e of a.paths)for(let s=0;s<e.length-1;s++){const m=g(e[s],e[s+1],t),y=c+m;if(y===n){const i=new R({x:e[s+1][0],y:e[s+1][1],z:e[s+1][2],...a.hasM?{m:e[s+1][h]}:{},hasZ:!0,spatialReference:a.spatialReference});return r===0?i:u(i,[e[s],e[s+1]],r)}if(y>n){const i=H(w(e[s]),w(e[s+1]),n-c,t),x=new R({x:i[0],y:i[1],z:i[2],...h>-1?{m:b(e[s][h],e[s+1][h],m,n-c)}:{},hasZ:!0,spatialReference:a.spatialReference});return r===0?x:u(x,[e[s],e[s+1]],r)}c+=m}if(c===0)return null;const f=a.paths.length-1,o=a.paths[f].length-1,p=[a.paths[f][o-1],a.paths[f][o]];let l=M(a,f,o);return l=z(l,p,n-c,t),u(l,p,r)}function G(a,n,r){const t=a.rings[n][r];return new R({spatialReference:a.spatialReference,x:t[0],y:t[1],hasZ:a.hasZ,hasM:a.hasM,z:a.hasZ?t[2]:void 0,m:a.hasM?a.hasZ?t[3]:t[2]:void 0})}function M(a,n,r){const t=a.paths[n][r];return new R({spatialReference:a.spatialReference,x:t[0],y:t[1],hasZ:a.hasZ,hasM:a.hasM,z:a.hasZ?t[2]:void 0,m:a.hasM?a.hasZ?t[3]:t[2]:void 0})}function I(a){return q(a.at(0),a.at(-1))}export{G as M,u as R,M as Z,A as f,F as g,C as l,D as p,I as x,E as y};
