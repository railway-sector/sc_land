const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/symbolLayerUtils-DKsAZfQu.js","assets/index-BrQW8HOS.js","assets/index-lUE0m221.css"])))=>i.map(i=>d[i]);
import{dh as f,dj as y,dk as d,dl as b,dm as w,dn as k,U as g,dp as L,at as v}from"./index-BrQW8HOS.js";import{S as z,u as S}from"./cimSymbolUtils-CmFYUdpV.js";import{y as j}from"./gfxUtils-DDSu4Luj.js";function x(n){const r=n.symbolLayers?.at(-1);if(r&&"outline"in r)return r?.outline?.size}function M(n){if(!n)return 0;if(y(n)){const r=x(n);return r??0}return v(j(n)?.width)}function T(n){if(n==null||!("symbolLayers"in n)||n.symbolLayers==null)return!1;switch(n.type){case"point-3d":return n.symbolLayers.some(r=>r.type==="object");case"line-3d":return n.symbolLayers.some(r=>r.type==="path");case"polygon-3d":return n.symbolLayers.some(r=>r.type==="object"||r.type==="extrude");default:return!1}}function V(n){return n.resource?.href??""}function B(n,r){if(!n)return null;let o=null;return y(n)?o=_(n):d(n)&&(o=n.type==="cim"?S(n):n.color?new f(n.color):null),o?c(o,r):null}function _(n){const r=n.symbolLayers;if(!r)return null;let o=null;return r.forEach(t=>{t.type==="object"&&t.resource?.href||(o=t.type==="water"?t.color:t.material?t.material.color:null)}),o?new f(o):null}function c(n,r){if(r==null||n==null)return n;const o=n.toRgba();return o[3]=o[3]*r,new f(o)}function E(n,r,o){const t=n.symbolLayers;if(!t)return;const e=(l,u=!1)=>{let i=r??l??null;return o?.override!=null&&(!i&&u&&(i=new f([255,255,255])),i&&(i.a=o.override)),c(i,o?.add)};t.forEach(l=>{if(l.type==="water")return void(l.color=c(l.color,o?.add));const u=l.material!=null?l.material.color:null,i=e(u,l.type==="icon"&&l.resource?.href!=null);l.material==null?l.material=new b({color:i}):l.material.color=i,"outline"in l&&l.outline?.color&&o?.add!=null&&(l.outline.color=c(l.outline.color,o.add)),"marker"in l&&l.marker!=null&&(l.marker.color=e(l.marker.color))})}function O(n,r,o){r=r??n.color,o?.override!=null&&r&&(r.a=o.override),r&&(n.color=c(r,o?.add)),"outline"in n&&n.outline?.color&&(n.outline.color=c(n.outline.color,o?.add))}function F(n,r,o){n&&(r||o!=null)&&(r&&(r=new f(r)),y(n)?E(n,r,o):d(n)&&O(n,r,o))}async function R(n,r){const o=n.symbolLayers;o&&await w(o,async t=>A(t,r))}async function A(n,r){switch(n.type){case"extrude":J(n,r);break;case"icon":case"line":case"text":D(n,r);break;case"path":P(n,r);break;case"object":await N(n,r)}}function D(n,r){const o=h(r);o!=null&&(n.size=o)}function h(n){for(const r of n)if(typeof r=="number")return r;return null}function J(n,r){const o=r[2];typeof o=="number"&&(n.size=o)}async function N(n,r){const{resourceSize:o,symbolSize:t}=await U(n),e=p(r,o,t);e!=null&&(n.width=s(r[0],t[0],o[0],e),n.depth=s(r[1],t[1],o[1],e),n.height=s(r[2],t[2],o[2],e))}function P(n,r){const o=p(r,k,[n.width,void 0,n.height]);o!=null&&(n.width=s(r[0],n.width,1,o),n.height=s(r[2],n.height,1,o))}function p(n,r,o){for(let t=0;t<3;t++){const e=n[t];switch(e){case"symbol-value":{const l=o[t];return l!=null?l/r[t]:1}case"proportional":break;default:if(e&&r[t])return e/r[t]}}return null}async function U(n){const{computeObjectLayerResourceSize:r}=await g(()=>import("./symbolLayerUtils-DKsAZfQu.js"),__vite__mapDeps([0,1,2])),o=await r(n,10),{width:t,height:e,depth:l}=n,u=[t,l,e];let i=1;for(let a=0;a<3;a++){const m=u[a];if(m!=null){i=m/o[a];break}}for(let a=0;a<3;a++)u[a]==null&&(u[a]=o[a]*i);return{resourceSize:o,symbolSize:u}}function s(n,r,o,t){switch(n){case"proportional":return o*t;case"symbol-value":return r??o;default:return n}}function $(n,r){const o=h(r);if(o!=null)switch(n.type){case"simple-marker":n.size=o;break;case"picture-marker":{const t=n.width/n.height;t>1?(n.width=o,n.height=o*t):(n.width=o*t,n.height=o);break}case"simple-line":n.width=o;break;case"text":n.font.size=o}}async function G(n,r){if(n&&r)return y(n)?R(n,r):void(d(n)&&$(n,r))}function H(n,r,o){if(n&&r!=null){if(y(n)){const t=n.symbolLayers;t&&t.forEach(e=>{if(e.type==="object")switch(o){case"tilt":e.tilt=(e.tilt??0)+r;break;case"roll":e.roll=(e.roll??0)+r;break;default:e.heading=(e.heading??0)+r}e.type==="icon"&&(e.angle+=r)})}else if(d(n))switch(n.type){case"simple-marker":case"picture-marker":case"text":n.angle+=r;break;case"cim":z(n,r,!0)}}}function K(n,r){if(!n)return null;const o=n.effects.map(t=>t.toJSON());return L(o)}function Q(n){return n!=null&&n.type==="polygon-3d"&&n.symbolLayers.some(r=>r.type==="extrude")}export{Q as A,F as L,G as M,H as N,B as b,V as d,T as h,M as m,K as q};
